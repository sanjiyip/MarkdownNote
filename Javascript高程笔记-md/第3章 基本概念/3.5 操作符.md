# 3.5 操作符（运算符）
------
> EMCA-262描述了一组用于操作数据值的**操作符**，包括算术操作符（如加号和减号）、位操作符、关系操作符和相等操作符。EMCAScript操作符与众不同的地方在于，它能够适用于很多值，例如字符串、数字值、布尔值，甚至对象。

## 3.5.1 一元操作符（❤）
只能操作一个值的操作符叫做**一元操作符**。

### 1. 递增和递减操作符

递增和递减操作符各有两个版本：**前置型**和**后置型**，前置型位于操作的变量之前，后置型应该位于操作变量之后。
- #### 前置递增和递减操作符
    - 执行**前置递增和递减操作**时，*变量的值都是在语句被求值以后改变的*。（在计算机领域被称作**副效应**）。
    - 口诀：**先求值**，后运算。(求值是求变量自身的值，运算是运算和该变量有关的语句。)
    ```js
    var num1 = 2;
    var num2 = 20;
    var num3 = --num1 + num2;//等于21
    var num4 = num1 + num2;//等于21
    ```
- #### 后置递增和递减操作符
    - **后置递增和递减操作**是在包含它们的语句被求值之后才执行。（它们：*是指具有后置递增和递减操作符的变量*）
    - 口诀：**后求值**，先运算。(求值是求变量自身的值，运算是运算和该变量有关的语句。)
    ```js
    var num1 = 2;
    var num2 = 20;
    var num3 = num1-- + num2;//等于22
    var num4 = num1 + num2;//等于21
    ```
- #### 这4个操作符对任何类型的值都适用，还可以用于字符串、布尔值、浮点数值和对象。
    应用于不同类型值的时候，递增和递减操作符遵循下列规则。
    
    - 在应用于一个**包含有效数字字符的字符串**时，先将其转换为数字值，再执行加减1的操作。**字符串变量变成数字变量**。
    - 在应用于一个**不包含有效数字字符的字符串**时，将变量的值设置为`NaN`。**字符串变量变成数字变量**。
    - 在应用于**布尔值**`true`时，先将其转换为0再执行加减1的操作。**布尔值变量变成数值变量**。
    - 在应用于**布尔值**`false` 时，先将其转换为1再执行加减1的操作。**布尔值变量变成数值变量**。
    - 应用于**浮点数值**时，执行加减1的操作。
    - 应用于**对象**时，先调用对象的`valueOf()`方法，以取得一个可供操作的值。然后对该值应用前述规则。如果结果是`NaN`,则在调用`toString()`方法后再应用前述规则。**对象变量变成数值变量**。
    ```js
    var s1 = "2";
    var s2 = "z";
    var b = false;
    var f = 1.1;
    var o = {
        valueOf: function() {
            return -1;
        }
    };

    s1++;//值变成数值3
    s2++;//值变成NaN
    b++;//值变成数值1
    f--;//值变成数值0.10000000000000009(浮动舍入误差导致)
    o--;//值变成数值-2
    ```

### 2. 一元加和减操作符(+)
- #### 一元加
    - 一元加操作符以一个加号（+）表示，放在数值前面，对数值不会产生任何影响。
    ```js
    var num = 25;
    num = +num;  //仍然是25
    ```
    - 在对**非数值类型**应用*一元加操作符*时，该操作符会像`Number()`转型函数一样对这个值执行转换。简单点说，就是添加了一元加操作符的值，会试图转为数值类型。如：布尔值false和true将被转换成0和1。
    ```js
    var s1 = "2";
    var s2 = "z";
    var b = false;
    var f = 1.1;
    var o = {
        valueOf: function() {
            return -1;
        }
    };

    +s1;//值变成数值2
    +s2;//值变成NaN
    +b;//值变成数值0
    +f;//值变成数值1.1
    +o;//值变成数值-1
    ```
- #### 一元减(-)
    - 一元减操作符主要用于表示负数。
    ```js
    var num = 25;
    num = -num; //变成了-25
    ```
    - 同理，对**非数值类型**应用一元减操作符时，和一元加操作符相同的规则，最后再将得到的数值转换为负数。

------

## 3.5.2 位操作符 （了解）
参考：[ECMAScript 位运算符](http://www.w3school.com.cn/js/pro_js_operators_bitwise.asp)

- 按位非(NOT)
- 按位与(AND)
- 按位或(OR)
- 按位异或(XOR)
- 左移(\<<)
- 有符号的右移(\>>)
- 无符号的右移(\>>>)

ECMAScript 整数有两种类型，即有符号整数（允许用正数和负数）和无符号整数（只允许用正数）。*在 ECMAScript 中，所有整数字面量默认都是有符号整数*。只有 ECMAScript 的位运算符才能创建无符号整数。

- **有符号整数**使用 31 位表示整数的数值，用*第32位*表示整数的符号，0 表示正数，1 表示负数。数值范围从 -2147483648 到 2147483647。**无符号整数**的数值范围为 0 到 4294967295。
- **有符号整数**可以以两种不同的方式存储二进制形式的有符号整数，一种用于存储正数，一种用于存储负数。正数是以真二进制形式存储的。


### 1. 位运算 `NOT`—— 求反码的过程
位运算 `NOT` 由波浪线（`~`）表示，执行运算符 NOT的结果就是返回**数值的反码**。它是 ECMAScript 中为数不多的与二进制算术有关的运算符之一。

```js
var num1 = 25;       //25 等于 00000000000000000000000000011001
var num2 = ~num1;   //转换为 11111111111111111111111111100110
console.log(num2); //输出 -26
```
**位运算 NOT 实质**上是**对数字求负，然后减 1**，因此 25 变 -26。用下面的方法也可以得到同样的方法：
```js
var num1 = 25;     
var num2 = -num1 - 1;   
console.log(num2); //输出 -26
```

### 2. 位运算 `AND`
位运算 AND 由和号（`&`）表示，直接对**数字的二进制形式进行运算**。它把每个数值的每一位对齐，然后用下面的规则对同一位置上的两个数位进行 AND 运算：**任何一位是0**，结果都是**0**。
```js
var result = 25 & 3;
console.log(result); // 1
```
```
 25 = 0000 0000 0000 0000 0000 0000 0001 1001
  3 = 0000 0000 0000 0000 0000 0000 0000 0011
---------------------------------------------
AND = 0000 0000 0000 0000 0000 0000 0000 0001
```
上面这个例子，先将两个数转为二进制形式，然后对比对应的每一位数。如果对应的数字都是1，才返回1。任何一位是0，；

### 3. 位运算 `OR`
位运算 OR 由符号（`|`）表示，也是直接对**数字的二进制形式进行运算**。在计算每位时，OR 运算符采用下列规则：有一个位是1的情况下就返回1，而只有在**对应两个位都是0**的情况下才返回**0**。
```js
var result = 25 | 3;
console.log(result); // 27
```
```
25 = 0000 0000 0000 0000 0000 0000 0001 1001
3  = 0000 0000 0000 0000 0000 0000 0000 0011
--------------------------------------------
OR = 0000 0000 0000 0000 0000 0000 0001 1011
```
可以看出，在两个数字中，共有 4 个数位存放的是 1，这些数位被传递给结果。二进制代码 11011 等于 27。

### 4. 位运算 `XOR`(异或)
位运算 XOR 由符号（`^`）表示，当然，也是直接对二进制形式进行运算。XOR 不同于 OR，如果**对应的两位都是1或都是0**，则返回**0**；

对 25 和 3 进行 XOR 运算，代码如下：
```js
var iResult = 25 ^ 3;
alert(iResult);	//输出 "26"
25 和 3 进行 XOR 运算的结果是 26：
```
```
 25 = 0000 0000 0000 0000 0000 0000 0001 1001
  3 = 0000 0000 0000 0000 0000 0000 0000 0011
---------------------------------------------
XOR = 0000 0000 0000 0000 0000 0000 0001 1010
```

### 5. 左移运算（`<<`）
左移运算由两个小于号表示（`<<`）。它把数字中的**所有数位向左移动**指定的数量。例如，把数字 2（等于二进制中的 10）左移 5 位，结果为 64（等于二进制中的 1000000）：*移多少位就叫多少个0*
```js
var oldValue = 2;               //等于二进制 10
var newValue = oldValue << 5;  //等于二进制 1000000 , 十进制 64
```
***注意***：左移运算保留数字的符号位。例如，如果把 -2 左移 5 位，得到的是 -64，而不是 64。

### 6. 右移运算(`>>`)
有符号右移运算符由两个大于号表示（>>）。它把 32 位数字中的所有数位整体右移，同时保留该数的符号（正号或负号）。**有符号右移运算符**恰好与左移运算相反。例如，把 64 右移 5 位，将变为 2：
```js
var iOld = 64;		//等于二进制 1000000
var iNew = iOld >> 5;	//等于二进制 10 十进制 2
```

### 7. 无符号的右移运算(`>>>`)
无符号右移运算符由三个大于号（>>>）表示，它将无符号 32 位数的所有数位整体右移。**对于正数，无符号右移运算的结果与有符号右移运算一样**。
```js
var iOld = 64;		//等于二进制 1000000
var iNew = iOld >>> 5;	//等于二进制 10 十进制 2
```
**对负数，无符号右移运算的结果与有符号右运算就不一样了**

首先，无符号右移是以0来填充空位（负数就会变正数）。其次，无符号右移会操作符会把负数的二进制码当做整数的二进制码。而且，由于**负数以其绝对值的 *二进制补码* 形式表示**，因此无符号右移的结果会非常之大。
```js
var oldValue = -64;		//等于二进制 111111111111111111111111100000
//十进制64的二进制值为10000，-64的要通过二进制补码得到
var newValue = iOld >>> 5;	//等于十进制 134217726
```
-----

## 3.5.3 布尔运算符
布尔运算符（也叫逻辑运算符），逻辑运算符共有3个：**逻辑非(NOT)**、**逻辑与(AND)**、**逻辑或(OR)**

### 1. 逻辑非(NOT)
**逻辑NOT**运算符由感叹号（`!`）表示。逻辑非运算符首先会将他的操作数转换为布尔值，然后再对其取反。
与逻辑 OR 和逻辑 AND 运算符不同的是，**逻辑 NOT 运算符返回的一定是 Boolean 值**。
```js
console.log(!false);  //true
console.log(!"blue"); //false
console.log(!0);      //true
console.log(!NaN);    //true
console.log(!"");     //true
console.log(!1234);   //false
```
逻辑非运算符也可以将一个值转换为与其对应的布尔值（使用`!!`）
```js
console.log(!!false);  //false
console.log(!!"blue"); //true
console.log(!!0);      //false
console.log(!!NaN);    //false
console.log(!!"");     //false
console.log(!!1234);   //true
```

### 2. 逻辑与(AND)
逻辑与(AND)运算符两个和号（`&&`）表示：
```js
var result = true && false;  //false
```
**在一个操作数不是布尔值的情况下，逻辑与运算不一定返回布尔值。**

此时逻辑与(`AND`)遵循下列规则：

- 如果第一个操作数是对象，则返回第二个操作数；

- 如果第二个操作数是对象，则只有在第一个操作数的求值结果为true的情况下才会返回该对象；

- 如果两个操作数都是对象，则返回第二个操作数；

- 如果第一个操作数是null，则返回null；

- 如果第一个操作数是NaN，则返回NaN；

- 如果第一个操作数是undefined，则返回undefined；

逻辑与(`AND`)运算属于**短路操作**，即如果第一个操作数能决定结果（false），那么就不会再对第二个操作数求值。但要注意：**不能在逻辑与运算中使用 *未声明* 的值**，不报错。
```js
var found = true;
var result = (found && someUndefinedVariable); //这句代码会被报错，因为有变量未被声明
console.log(result); //不会执行
```

下面这个例子不会报错，就因为逻辑与的短路操作特性，因为第一个操作数能决定结果的话，第二个操作数的值是什么并不影响。
```js
var found = false;
var result = (found && someUndefinedVariable); //不会报错，因为逻辑与操作结果必定是false，所以无需管&&右边的值
console.log(result); //会执行，打印"false";
```
### 3. 逻辑或(OR)
逻辑或(OR)运算符两个竖线符号（`||`）表示：
```js
var result = true || false;  //true
```
与逻辑与运算相似，**在一个操作数不是布尔值的情况下，逻辑或运算也不一定返回布尔值。**

此时逻辑或(`OR`)遵循下列规则：

- 如果第一个操作数是对象，则返回第一个操作数；

- 如果第一个操作数求值结果是false，则返回第二个操作数;

- 如果两个操作数都是对象，则返回第一个操作数；

- 如果**两个**操作数是null，则返回null；

- 如果**两个**操作数是NaN，则返回NaN；

- 如果**两个**操作数是undefined，则返回undefined；

逻辑或(`OR`)运算也属于**短路操作**。也就是说，如果一个操作数的求值结果为true，就不会对第二个操作数求值了。
```js
var found = true;
var result = (found || someUndefinedVariable); //不报错
console.log(result); //会执行，"true",由于短路操作特性，逻辑或已经有结果了
```
下面会报错的原因是，首先这里逻辑或运算中第一个操作符是false，还没有得到结果（检查有没有true），再检查第二个操作数，发现没有变量没被声明，因此报错。
```js
var found = false;
var result = (found || someUndefinedVariable); //会报错
console.log(result); //不会执行
```
**使用逻辑或来避免变量funull或undefined值**

------

## 3.5.4 乘性运算符
### 1. 乘法
乘法运算符由星号（`*`）表示，用于两数相乘。

### 2. 除法
除法运算符由斜杠（`/`）表示，用第二个运算数除第一个运算数。

### 3. 求余
除法（余数）运算符由百分号（`%`）表示.

------

## 3.5.5 加性运算符
### 1. 加法
加法运算符由加号（`+`）表示。

如果某个运算数是字符串，那么采用下列规则：
- 如果两个运算数都是字符串，把第二个字符串连接到第一个上。
- 如果只有一个运算数是字符串，把另一个运算数转换成字符串，结果是两个字符串连接成的字符串。
```js
var result = 5 + 5;	//两个数字
alert(result);		//输出 "10"
var result2 = 5 + "5";	//一个数字和一个字符串
alert(result);		//输出 "55"
```

### 2. 减法
减法运算符（`-`），也是一个常用的运算符。

------

## 3.5.5 关系运算符
关系运算符小于、大于、小于等于和大于这四个运算符都返回一个**布尔值**。
### 常规数值间比较

### 字符串间比较
**比较字符串时，实际比较的是两个字符串中对应位置的每个字符的字符编码值。**
```js
var result = "Blue" < "alpha";
console.log(result);	//输出 true
//因为字母 B 的字符编码是 66，字母 a 的字符代编码是 97。
```
要强制性得到按照真正的字母顺序比较的结果，必须把两个数转换成相同的大小写形式（全大写或全小写的），然后再进行比较：
```js
var result = "Blue".toLowerCase() < "alpha".toLowerCase();
console.log(result);	//输出 false
```
不过，如果字符串不能转换成数字又该如何呢？考虑下面的例子：
```js
var result = "a" < 3;
alert(result);
```
字母 "a" 不能转换成有意义的数字。不过，如果对它调用 `parseInt()` 方法，返回的是`NaN`。根据规则，**任何包含 `NaN` 的关系运算符都要返回 `false`。**
```js
var result1 = NaN < 3;  //false
var result2 = NaN >= 3; //false
```
------

## 3.5.7 相等运算符
> 判断两个变量是否相等是程序设计中非常重要的运算。ECMAScript 提供了两套等性运算符：
> - 相等(`==`)和不相等(`!=`)——**先转换再比较**
> - 全等号(`===`)和不全等号(`!==`)——**仅比较而不转换**
> - 两套返回值都是布尔类型

```js
var result1 = (null == undefined); //true
var result2 = (null === undefined); //false
var result3 = ("55" == 55); //true
var result4 = ("55" === 55); //false
```
为了保持代码中数据类型的完整性，推荐使用**全等和不全等操作符**。

-----

## 3.5.8 条件运算符（三目运算符）
语法：
```js
variable = boolean_expression ? true_value : false_value;
```
该表达式主要是根据 boolean_expression 的计算结果有条件地为变量赋值。如果 Boolean_expression 为 true，就把 true_value 赋给变量；如果它是 false，就把 false_value 赋给变量。

------

## 3.5.9 赋值运算符
简单的赋值运算符由等号（`=`）实现，只是把等号右边的值赋予等号左边的变量。

每种主要的算术运算以及其他几个运算都有复合赋值运算符：
- 乘法/赋值（*=）
- 除法/赋值（/=）
- 取模/赋值（%=）
- 加法/赋值（+=）
- 减法/赋值（-=）
- 左移/赋值（<<=）
- 有符号右移/赋值（>>=）
- 无符号右移/赋值（>>>=）

------

## 3.5.10 逗号运算符
逗号运算符除了平时的用法，其实还可以用于赋值
```js
var num = (5, 1, 4, 8, 0); //num值为0
```
-----

摘抄自《JavaScript高级程序设计》

