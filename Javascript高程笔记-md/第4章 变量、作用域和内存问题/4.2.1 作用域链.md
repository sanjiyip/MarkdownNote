# 作用域链(scope chain)
---
当代码在一个环境中执行时，会创建**变量对象**(`VO`)的一个**作用域链**。

- 作用域链，是由当前环境与上层环境的一系列变量对象组成，是保证对执行环境有权访问的所有变量和函数的有序访问。

- 作用域链的前端始终都是当前执行的代码所在环境的对象变量。如果这个环境是函数（function context），则将其活动对象(activation object)作为变量对象。活动对象在最开始只包含一个变量，即arguments对象（这个对象在全局环境中是不存在的）。作用域链中的下一个变量对象来自包含（外部）环境，而再下一个变量对象则来自下一个包含环境。这样，一致延续到全局执行环境；全局执行环境的变量对象始终都是作用域链中的最后一个对象。

**标识符解析**（程序代码中用来标识一个变量、函数、或者属性的字符序列。这里的标识符，指的是变量名或者函数名）是沿着作用域作用域链一级一级地搜索标识符的过程。搜索过程始终从作用域链的前端开始，然后逐级地向后回溯，直至找到标识符位置（如果找不到标识符，通常会导致错误发生）。

在局部作用域中定义的变量可以在局部环境中与全局变量互换使用。例子：
```js
var color = "blue";
function changeColor() {
    var anotherColor = "red";
    function swapColors () {
        var tempColor = anotherColor;
        anotherColor = color;
        color = tempColor;
        //这里可以访问color、anotherColor和tempColor
    }
    //这里可以访问color、anotherColor，但不能访问tempColor
}
//这里只能访问color
changeColor();
```
以上代码涉及3个执行环境：全局环境，changColor的局部环境（函数环境），swapColors的局部环境。
- 全局环境中有一个变量color和一个函数changeColor()。

- changColor()的局部环境中有一个名为anotherColor的变量和一个名为swapColors()函数。

- swapColors()的局部环境中有一个名为tempColor的变量。

上面代码说明了：
- **内部环境（函数环境）可以通过作用域访问所有的外部环境(是指：上一级函数环境或是全局环境)，但外部环境不能访问内部环境中的任何变量和函数。**

- 这些环境之间的联系是线性、有次序的。

- 每个环境都可以向上搜索作用域链，以查询变量名和函数名；

- 但是任何环境都不能通过向下搜索作用域链而进入另外一个执行环境(指的是下级的函数环境)

---
**说明几个同义词**
- 全局环境 = 全局执行环境 = 外部环境

- 函数环境 = 函数执行环境 = 局部环境 = 内部环境（因为全局环境不可能是内部环境）=（但函数环境有时候也会是某个内部环境的外部环境：函数嵌套的时候function里面声明function）

---
## 4.2.1延长作用域
虽然执行环境的类型总共只有两种——全局和局部（函数），但是含有其他办法来延长作用域链。这么说是因为**有些语句可以在作用域链的前端临时增加一个变量对象，该变量对象会在代码执行后被移除**。

在有种情况下会发生这种现象。具体来说，就是当执行流进入下列任何一个语句时，作用域链就会得到加长：
- `try-catch`语句的`catch`块
- `with`语句

这两个语句都会在作用域链的前端添加一个**变量对象**。
- 对`with`语句来说，会将指定的对象添加到作用域链中。
- 对`catch`语句来说，会创建一个新的变量对象，其中包含的是被抛出的错误对象的声明。

```js
function buildUrl() {
    var qs = "?debug = true";
    with(location) {
        var url = href + qs; //with语句使得buildUrl()作用域延长到with里面，所以buildUrl()能够访问url，（按照正常是不能访问到的，因为外部环境不能访问内部环境中的任何变量和函数。）
    }
    return url;
}
```
在此，**with语句接收的是location对象，因此其变量对象中包含了location对象的所有属性和方法，而这变量对象被添加到作用域链的前端**。(好好体会这句话~)

buildUrl()函数定义了一个变量qs。当在with语句中引用变量href时（实际引用的是location.href），可以在当前执行环境的变量对象中找到。

当引用变量qs时，引用的则是在buildUrl()定义的那个变量，而该变量位于函数环境的变量对象中。至于with语句内部，则定义了一个名为url的变量，因为url就成了函数执行环境的一部分，所以可以作为函数的值被返回。

---

## 4.2.2 没有块级作用域

因为JavasScript没有块级作用域，所有会导致理解上的困惑。下面代码在Javascript中会返回这样的结果：
```js
if(true) {
    var color = "blue";
}
alert(color); //”blue“;
```
上面代码，如果在c++或者java中，color会在if语句执行完毕后被销毁。**但在Javascript中，`if语句`中的变量声明会将变量添加到当前的执行环境**中。

```js
function test() {
    if(true) {
        var color = "blue";
    }
    alert(color); //”blue“; 因为if语句中的变量声明会将变量添加到当前的执行环境中，这里是test()函数执行环境
}
test(); // "blue"
console.log(color); //报错，因为外部环境不能访问内部环境中的任何变量和函数。
```

**在使用`for语句`时尤其要牢记这一差异**，例如：
```js
for (var i=0; i < 10; i++) {
    doSomehting(i);
}
alert(i); //10
```
对于Javascript来说，由for语句创建的变量i即使在for循环执行结束后，依然会存在与循环体的外部执行环境中。

### **1.声明变量**
- 使用`var`声明的变量会自动被添加到最接近的执行环境中。在函数内部，最接近的环境就是函数的局部环境；在with语句中，最接近的环境是函数环境。
```js
function add(num1,num2) {
    var sum = num1 + num2;
    return sum;
}

var reusult = add(10, 20); //30
alert(sum); //由于sum不是有效变量，因此会报错。（因为在这里，全局环境无法范围函数add()里面的sum，因为sum使用了var来声明）
```
- 如果初始化变量时没有`var`声明，该变量会自动被添加到全局环境中。（向上查询所有的函数环境，都没有与初始变量名字一样的`标识符`var声明的情况下，才自动添加到全局环境中。）如下所示：
```js
function add(num1,num2) {
    sum = num1 + num2;
    return sum;
}

var reusult = add(10, 20); //30
alert(sum); //3O   原因：在本例子中，没有var声明，所以自动添加到全局环境中
```
不声明而直接初始化变量是一个常见的错误做法。因此，为了避免不必要的意外，建议初始化变量之前，**一定要先声明**。

---

### **2.查询标识符** （important）

>当在某个环境中为了读取或写入而**引用一个标识符**时，必须通过搜索来确定标识符实际代表什么。

**标识符查找过程**：（很重要！！！！）

- 搜索过程从作用域链的前端开始（作用域链的前端是指：想要引入标识符的函数环境），向上逐级查询与给定名字匹配的标识符（即带var关键字声明，且同名的标识符）。

- 如果在**局部环境中找到了该标识符，搜索过程停止**，变量就绪。

- 如果在局部环境中没找到该变量名，继续沿作用域链向上搜索。

- 搜索过程将一直追溯到全局环境的变量对象。如果全局环境中也没找到这个标识符，则意味着该变量尚未声明。 (才自动变成全局变量)

通过下面示例，来理解查询标识符的过程：
```js
var color = "blue";
function getColor () {
    return color;
}
console.log(getColor()); //"blue"
```
调用上面例中的函数getColor()时需要引入**变量color**，为了确定变量color的值，将开始一个搜索标识符的过程。首先，搜索getColor()的变量对象，查找其中是否包含一个名为color的标识符。在没找到的情况下，搜索继续到下一个变量对象（该例子下一个是全局环境的变量对象），然后在那里找到了名为color的标识符。因为搜到定义了这个变量的变量对象，搜索过程宣告结束。

---

**在搜索过程中，如果存在一个局部的变量的定义，则搜索会自动停止，不再进入另一个变量对象**。

换句话说，如果局部环境中存在着同名标识符，就不会使用父环境中的标识符，如下例子所示：
```js
var color = "blue";
function getColor () {
    var color = "red";
    return color;
}
alert(getColor()); //"red"
```

```js
var name = "first";
function first() {
    var name = "second";
    function second() {
        name = "third";
        console.log(name);
    }
    second();
    console.log(name);
}
first();
console.log(name);
```

这里的结果是什么自己试试就知道。

这个例子印证了作用域链的作用。
在函数内部出现一个没有被声明的标识符（没有var的函数名），首先JS引擎会先在该作用域内找有没有**var 该标识符名**，没找到的话，继续向上一级的环境的作用域找，找到了就认为这个标识符代表上一级的那个var变量声明，然后把值赋给上一级的那个同名的变量。（可以这么做是因为作用域链可以向上访问，但是不能向下访问），只要找到var声明的同名标识符以后，这个查找的过程结束，不会影响到其他环境下的变量。所以，不是没有var的标识符就被默认为是全局变量，只有找不到的情况下才是！

----
## 作用域链补充
>The `scope chain` property of each `execution context` is simply a collection of the current `context's` `[VO]` + all parent’s lexical `[VO]`s.

VO指的是Variable Object，变量对象


