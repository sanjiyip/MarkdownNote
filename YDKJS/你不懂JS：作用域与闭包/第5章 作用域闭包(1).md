# 作用域闭包（1）

## 5.1 启示

## 5.2 实质问题

当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数时当前词法作用域之外执行。

举例：
```js
function foo() {
    var a = 2;
    function bar () {
        console.log(a);
    }
    bar();
}
foo();
```

这段代码看起来和嵌套作用域中的示例代码很相似。基于词法作用域的查询规则，函数bar()可以访问作用域中的变量a（这个例子中的RHS引用查询）。

这是闭包吗？

技术上讲，也许是。但根据前面的定义，确切说并不是。我认为最准确地用来解释bar()对a的引用方法是词法作用域的查找规则，而这些规则知识闭包的一部分。（但却是非常重要的一部分）

从纯学术的角度讲，上面代码，函数bar（）具有一个涵盖foo（）作用域的闭包（事实上，涵盖了它能访问的所有作用域，比如全局作用域）。也可以认为bar（）被封闭在foo（）的作用域中。因为bar（）嵌套在foo（）内部。

看一段代码，清晰展示了闭包：
```js
function foo() {
    var a = 2;
    function bar() {
        console.log(a);
    }
    return bar;
}

var baz = foo();

baz();  //2 —— 朋友，这就是闭包的效果
```

使用另一种方式对函数类型的值进行传递，当函数在别处调用时，都可以观察到闭包。
```js
function foo() {
    var a = 2;
    function baz() {    //条件1：内部函数
        console.log(a); //条件2：内部函数内部调用了外部函数中的参数或变量
    }
    bar(baz);   //条件3：内部函数以函数值的形式传递到内部函数的作用域之外
}

function bar(fn) {
    fn();       //条件4：内部函数会在其所在的词法作用域之外的作用域被调用。妈妈快看，这就是闭包
                //确切来讲，fn()就是baz()
}
```
把内部函数baz传递给bar，当调用这个函数时（现在叫做fn），它涵盖的foo（）内部作用域的闭包就可以察觉到了，因为它访问了a。

**一般形成闭包的4个条件**：集齐4个条件即可召唤神龙(闭包)
- 条件1：有内部函数
- 条件2：内部函数内部调用了外部函数中的参数或变量
- 条件3：内部函数以**函数值**的形式传递到内部函数所在的作用域之外的作用域
    - 函数值传递的方式有很多种，所以要多看别人怎么传递
- 条件4：内部函数在其所在的词法作用域之外的作用域被调用。


传递函数当然也可以间接的。
```js
var fn;
function foo() {
    var a =2;
    function baz () {
        console.log(a);
    }

    fn = baz;   //将baz分配给全局变量
}

function bar() {
    fn();      //妈妈快快看，这就是闭包！
}

foo();

bar();
```

----

## 5.3 现在我懂了

我保证闭包绝不仅仅是一个好玩的工具。
```js
function wait(message) {
    setTimeout(function time(){
        console.log(message);
    }, 1000);
}

wait("Hello, closure!");
```

将一个内部函数（名为timer）传递给setTimeout()。timer具有涵盖wait()作用域的闭包，因此还保有对变量message的引用。

wait()执行1000毫秒后，它的内部作用域并不会消失，timer函数依然保留有wait()作用域的闭包。

这就是闭包。

原来，在一个函数使用setTimeout（定时器）就会形成闭包~

本质上，无论何时何地，如果将函数（访问他们各自的词法作用域）当作第一级的值类型到处传递，你就会看到闭包在这些函数中的应用。

在定时器、事件监听器、Ajax请求、跨窗口通讯、Web Worker或者任何其他的异步（或者同步）任务中，只要使用了**回调函数**，实际上就是在使用闭包！


### **IIFE模式是不是闭包？**

在这里定义下，严格来说不算真正的闭包，但是技术上，它确实创建了闭包。

看例子：
```js
var a = 2;
(function IIFE(){   //条件1：有内部函数(这里是相对于全局而言)
    console.log(a); //条件2：调用了外部作用域的变量和参数
})();
```
**但是缺少了：**
- 条件3：内部函数以函数值的形式传递到其所在作用域之外的作用域
- 条件4：内部函数在其所在作用域之外的作用域被调用

虽然这段代码可以正常工作，但严格来讲它并不是闭包。因为函数(IIFE)并不是在它本身词法作用域以外执行的（条件4）。它在定义时所在的定义域中执行（而外部作用域，也就是全局作用域也持有a）。a是通过普通的词法作用域查找而非被闭包发现的。

尽管技术上讲，闭包是发生在定义时的，但并不非常明显。

尽管IIFE本身并不是观察闭包的恰当例子，但它的确创建了闭包，并且也是最想用来创建可以封闭起来的闭包的工具。

---

## 5.4 循环和闭包

要说明闭包， for循环是最常见的例子。
```js
for(var i=1; i<=5; i++) {
    setTimeout(function timer(){
        console.log(i);
    }, i*1000);
}
```
正常情况下，我们对这段代码行为的预期是分别输出数字1~5，每隔一秒输出一次，每次一个。

**但实际上，这段代码运行时会以每秒一次的频率输出5次6.**

这是为什么？

首先解释6是从哪里来的。这个循环的终止条件是i不再<=5。条件首次成立是i的值是6。因此，输出显示的是循环结束时i的最终值（因为全局作用域下，所有函数共享一个i）。

记住：**延迟函数的回调会在函数结束是才会执行**！！！（6就这样来的）

因为所有的回调函数依然是在循环结束后才被执行，因此会每次输出一个6出来。

到底是什么导致代码的行为同语义所暗示的不一致呢？

**缺陷**是我们试图假设循环中的每个迭代在运行时都会给自己“捕获”一个i的副本。

但根据作用域工作原理，实际情况是尽管循环中的五个函数是在各个迭代中分别定义的，但是他们都被封闭在一个共享的全局作用域中，因此实际只有一个i。也就说，所有函数都共享一个i的引用。

解决这个问题，我们需要更多的闭包作用域，特别是在循环的过程中每个迭代都需要一个闭包作用域。

方法：**IIFE通过声明并立即执行有个函数来创建作用域**。

```js
for(var i=1; i<=5; i++) {
    (function(){
        setTimeout(function timer(){
            console.log(i);
        }, i*1000);
    })();
}
```
不过这样还不够，如果作用域是空的，那么仅仅将他们进行封闭是不够的。仔细看，我们的IIFE只是一个什么都没有的空作用域。它需要包含一点实际内容才能为我们所用。

简单点说，我们还要为IIFE函数创建变量，目的是为了能让IIFE中的内部函数timer调用（条件2：调用了外部作用域的变量和参数），才能真正实现闭包的功能。

因此，它需要有自己的变量，用来在每个迭代中存储i的值：
```js
for(var i=1; i<=5; i++) {
    (function(){
        var j = i;
        setTimeout(function timer(){
            console.log(j);
        },j*1000)
    })();
}
```
yeah~能正常工作了~

不过还可以对代码进行改进，使用IIFE传递参数那种模式：
```js
for(var i=1; i<=5; i++) {
    (function(j){
        setTimeout(function timer(){
            console.log(j);
        }, j*1000);
    })(i);
}
```
**在迭代内使用IIFE会为每个迭代都生成一个新的作用域，使得延迟函数的回调可以将新的作用域封闭在每个迭代内部，内个迭代中都会含有一个具有正确值的变量供我们访问**。

### 重返块作用域

我们使用IIFE在每一次迭代都会创建一个新的作用域。而使用let声明，可以用来劫持块作用域（将普通块变成有作用域的块），并且在这个块作用域中声明一个变量。let本质上这是将一个普通块转换为一个可以被关闭的作用域块（现在功能函数作用域一样）。



```js
for (var i=1; i<=5; i++) {

    {// 为了更好理解let的功能，我显式显示了块作用域，不加大括号也行。
        //因为使用了let声明，使let所在的块拥有了块作用域（和函数作用域一样有效）
        let j = i;
        setTimeout(function timer(){
            console.log(j);
        },j*1000);
    }
}
```

但是，这还不是全部！

for循环的头部的let声明还会有一个特殊的行为。

这个行为指出头部的变量在循环过程中不值被声明一次，每次迭代都会声明。随后的每个迭代都会使用上一个迭代结束时的值来初始化这个变量。

```js
for(let i=1; i<=5; i++) {
    setTimeout(function timer(){
        console.log(i);
    }, i*1000);
}
```

块作用域和闭包联手便可以天下无敌。
从此我就成为了一名快乐的JS程序员~

---


