# **值**

数组（array）、字符串（string）和数字（number）是程序最基本的组部分，但在JS中，它们可谓让人喜忧参半。

# 2.1 数组（Array）

在JS中，数组可以容纳任何类型的值，可以是字符串、数字、对象甚至其他数组（多维数组就是通过这种方式来实现的）：
```js
var a = [1, "2", [3]];

a.length;   //3
a[0] === 1; //true
a[2][0] === 3;  //true
```

数组声明后既可以向其中加入值，不需要预先设定大小：
```js
var a = [];
a.length;   //0
a[0] = 1;
a[1] = "2";
a[2] = [3];

a.length;   //3

```

创建“稀疏”数组（即含有空白或空缺单元的数组）时要特别注意：
```js
var a = [];
a[0] = 1;
// 此处没有设置a[1]单元
a[2] = [3];

a[1];   //undefined

a.length;   //3
```

上面的代码可以正常运行，但其中的“空白单元”（empty slot），a[1]的值为undefined，但这与将其显式赋值为undefined(即`a[1] = undefined`)还是有区别的。

### 数组中的字符串键值和属性

数组可以通过数字进行索引，但有趣的是数组本身也是对象，所以可以包含字符串键值和属性（但这些并不计算在数组长度内）：
```js
var a = [];
a[0] = 1;
a["foobar"] = 2;

a.length;   // 1 字符串键值和属性不计算在数组长度内
a["foobar"];    // 2
a.foobar;       // 2
```

特别注意：**如果字符串键值能够被强制转换为十进制数字的话，它就会被当作数字索引来处理**。

```js
var a = [];
a["13"] = 42;
a.length;   //14
```

数组中加入字符串键值/属性并不是一个好主意。

因此建议使用对象来存放键值/属性值。用数组存放数字索引值。


### **类数组**

有时需要将类数组（一组通过数字索引的值）转换为真正的数组，要通过数组工具函数（如`indexOf()`、`concat()`、`forEach()`等）来实现。

例如，一些DOM查询操作会返回DOM元素列表，它们并非真正意义上的数组，但十分类似。（比如`document.getElementsByClassName()`返回的就是类数组）

另外一个类数组的例子是通过arguments对象(类数组)将函数的参数当作列表来访问（ES6开始已废止）。

**工具函数slice()经常被用于把类数组转换为数组**。

```js
function foo() {
    var arr = Array.prototype.slice.call(arguments);
    arr.push("bam");
    console.log(arr);
}

foo("bar", "baz");  //["bar", "baz", "bam"]
```

slice()返回参数参数列表的一个数组复本。

用ES6中内置的工具函数Array.from(..)也能实现同样的功能：

```js
function foo() {
    var arr = Array.from(arguments);
    arr.push("bam");
    console.log(arr);
}

foo("bar", "baz"); 
```
`Array.from(..)`有一些非常强大的功能。



# 2.2 字符串（string）

JavaScript中的字符串和字符串数组并不是一回事，最多看上去相似而已。

字符串和数组的确有相似的地方，都有`length`属性已经`indexOf()`和`concat()`方法：

```js
var a = "foo"; 
var b = ["f","o","o"];

a.length;   //3
b.length;   //3

a.indexOf("o"); //1
b.indexOf("o"); //1

var c = a.concat("bar");            //"foobar"
var d = b.concat(["b","a","r"]);    // ["f", "o", "o", "b", "a", "r"]

a === c;    //false
b === d;    //false

a;      //"foo"
b;      //["f","o","o"]
```

但是，字符串不是数组。

**JS中字符串时不可变的，而数组是可变的**。（第一个不同点）

字符串不可变是指字符串的成员函数不会改变其原始值，而是创建并返回一个新的字符串。

而数组的成员函数（内置数组对象的函数）都是在其原始值上进行操作的。

比如:
```js
var a = "foo"; 
var b = ["f","o","o"];

c = a.toUpperCase();
a === c; //false
a;  //"foo"
c;  //"FOO"

b.push("!");
b;      //["f","o","o","!"];
```

许多数组函数用来处理字符串很方便。虽然字符串没有这些函数，但是可以通过“借用”数组的非变更方法来处理字符串：
```js
a.join; //undefined join是将数组转换成字符串
a.map;  //undefined

var c = Array.prototype.join.call(a, "-");
var d = Array.prototype.map.call(a,function(v){
    return v.toUpperCase() + ".";
}).join("");    

c;  //"f-o-o"
d;  //"F.O.O."
```

### 通过数组的方法来实现字符串反转

另外一个不同点在于，字符串反转。

数组有一个字符串没有的，而数组本身有的方法reverse():
```JS
var a = "foo"; 
var b = ["f","o","o","!"];

a.reverse;  //undefined

b.reverse();  // ["!", "o", "o", "f"]
b;            // ["!", "o", "o", "f"]
```

可惜我们无法“借用”数组的可变更成员函数，因为字符串是不可变的：
```js
Array.prototype.revers.call(a);
//返回值仍然是字符串“foo”的一个封装对象
```

一个变通（破解方法）办法是将字符串转换为数组，待处理完在将结果转回字符串：

```js
var a = "foo"; 
var c = a.split("").reverse().join("");
//将a的值转换为字符串数组，然后将数组中的字符进行倒转，最后将数组中的字符拼接成字符串
c;  //"oof"

```

方法简单粗暴，对简单的字符串完全使用。



