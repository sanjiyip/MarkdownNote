
# 2.5 值和引用

**记住：我们无法自行决定是使用值复制还是按共享传递，一切由值的类型来决定**

**JS中的基本类型值是按值传递，复杂类型值是按共享传递**。重点重点重点！！！！！！！

首先规定好JS值类型的名字，统一下来，以后就按着那样叫，不要改来改去，知道是什么就行。

### **1. 基本类型值**（又称简单值、基本数据类型值）

包括：string、number、boolean、null、undefined 和 symbol（ES6新增）

### **2. 复杂类型值**（又称**复合值**、**引用类型值**、**对象类型**）

包括：Object、Array、Date、String、RegExp、Function等**内置对象** 和 **自定义对象**。

---

## **2.5.1 复制变量值**

### 1. 变量值为**基本类型值**时的赋值与传递

在Javascript中变量不可能成为指向另一个变量的引用。

**因为JS中的变量只是一个用于保存值的占位符而已，所以变量没有类型，只有值才有类型**！！！

**JS引用指向的是值**。如果一个值有10个引用，这些引用指向的都是同一个值，它们（变量）互相之间没有引用/指向关系。

JS对**值**和**引用**的赋值/传递在语法上没有区别，完全根据值的类型来决定。

```js
var a = 2;
var b = a;  //b是a的值的一个副本
b++；
a;  //2
b;  //3
```

**基本类型值总是通过值复制的方式来赋值/传递**。包括null、undefined、字符串、数字、布尔和ES6中的symbol。


### 2. 变量值为**复杂类型值**时的赋值与传递

**复杂类型值，总是按共享传递的方式来赋值/参数传递**。

看图：

![浅拷贝](images/浅拷贝-2.png)

```js
var a = [1,2,3];
var b = a;

b.push(4);  //[1,2,3,4]
a;          //[1,2,3,4]

b = ["a", "b", "c"];
b.slice(1); //["b", "c"]
a;          //[1,2,3,4]
```

---

## **2.5.2 函数的参数传递**

### 0. **复杂类型值的参数传递方式**

实际上有3种：

1. 按值传递（passed by value，纯按值传递）

    - 特征：对于传递过来的变量进行修改，不会影响到原变量。
    - 这种方式比较少见，因为对复杂类型的参数进行完全复制，会付出额外的空间与时间代价。


2. **按共享传递**，即**按值传递复杂值引用地址的副本**（call by sharing），或称为按地址值传递

    - 特征：对作为参数传入的对象进行修改时，会直接影响原对象；
    - 而如果对传入的参数进行重新赋值（值为复杂类型值），则不会影响原对象，并且此后再修改形参（对象），也不会对原对象造成影响。（这是与按引用传递的区别之处）

3. 按引用传递（passed-by-reference 纯按引用传递）

    - 特征：无论是对于变量成员的修改，还是对变量重新赋值，都会影响到原对象。

### **按共享传递**（call by sharing）

- 按共享传递 （call by sharing）
    - 准确的说，JS中的基本类型按值传递，对象类型按共享传递的(call by sharing，也叫按对象传递、按对象共享传递)。

    - 该策略的重点是：调用函数传参时，函数接受对象实参引用的**复本**(既不是按值传递的对象副本，也不是按引用传递的隐式引用)。 
    
    - 按共享传递和按引用传递的**不同在于**：在共享传递中,对函数形参的赋值，将不会影响实参（原对象）的值。

        - 形参：函数内的参数（形式参数，比如例子中：foo(x){x=1}中的 x ）
        - 实参：实际传入函数的参数（即调用函数时传入的内容，比如下例中调用函数foo(a);中的 a ）

    - 然而，虽然引用是副本，引用的对象是相同的。它们共享相同的对象，所以修改形参对象的属性值，也会影响到实参（原对象）的属性值。

引入“按共享传递”的求值策略，它让我们精确的区分按共享传递与经典的按值传递、按引用传递的不同。在这种情形下，可以按传参类型区分：“基本类型按值传递、而对象按共享传递。”


### 1. **基本类型值**作为参数出入函数时

这个过程不用过多解释，基本类型值是以**值传递（值复制）** 传入函数的参数中。

### 2. **复杂类型值（对象、数组）** 作为参数出入函数时

**参数传递是通过引用复制还是值复制完全由值的类型来决定**，所以使用哪种类型也间接决定了参数传递的方式

JavaScript中的参数传递属于第2种，**既不是纯粹的按值传递**，**又不是纯粹的按引用传递**。介于两者之间，按共享传递（call by sharing）。

- **JS中的参数是对象时，实际传入的是对象的引用地址一份复制（创建一个对象复本传入参数）。因为传递的是引用地址，修改传入参数中的对象成员（对象属性）会直接影响原对象，并且在传递过程中没有将原对象完全复制一份，从这一点上来看像是引用传递；但是如果对参数进行重新赋值，接着对参数进行操作，此时不会再影响原对象，从这一点上来看是值传递**。

看例子

```js
// 参数传递（实参为对象时）
var a = {x:1, y:2};

function Foo(o) {
    o.x = "changed";
    o = [1, 2, 3];  // 对形参 o 重新赋值，以后对 o 的操作将不再影响原对象 a。
    o.y = "can I change?";
}

Foo(a);             // 将对象 a 的引用地址的复本传递到函数的形参 o 中

console.log(a.x);   // "changed" 被改变了
console.log(a.y);   // 2  没变，对函数里面的形参重新赋值后,原对象(实参)不再受形参的影响
```

**对象作为参数时，传入的参数的是对象的一个引用地址的复本，但当对形参重新赋值以后，再对形参修改时，不再影响原来对象的值**。

[参考：call by sharing](http://bosn.me/js/js-call-by-sharing/)

----

另外一个例子（加深印象）

```js
function foo(x) {
    x.push(4);
    x;//[1,2,3,4]

    x.length = 0;   //清空数组
    x.push(4,5,6,7);
    x;//[4,5,6,7]
}

var a = [1,2,3];

foo(a);

a;  //是[4,5,6,7]
```

我们向函数传递a的时候，实际是将引用a的一个**复本**赋值给x（看上图），而a仍然指向[1,2,3]。

在函数中我们可以通过引用x来改变数组的值（push(4）之后变成[1,2,3,4]）。

**但当参数x被重新赋值**的时候，参数x的引用指向就被改变（x=[4,5,6]），但并不影响变量a的引用指向，所以a仍然指向[1,2,3,4]。

我们不能通过变量x的引用的指向来更改变量a的引用的指向，只能更改a和x共同指向的值。

如果要将a的值变为[4,5,6,7]，必须更改x指向的数组，而不是为x赋值一个新的数组。


从上例中可以看出，x.length = 0 和 x.push(4,5,6,7)并没有创建一个新的数组，而是更改了当前数组。于是a指向的值变成了[4,5,6,7]。
