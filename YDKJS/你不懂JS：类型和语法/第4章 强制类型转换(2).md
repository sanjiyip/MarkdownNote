# **强制类型转换**  

# 4.3 显式强制类型转换

显示强制类型转换时那些显而易见的类型转换，很多类型转换都属于此列。

类型转换越清晰，代码可读性越高，更容易理解。

## **4.3.1 字符串和数字之间的显式转换**

从最常见的字符串和数字之间的强制类型转换开始。

字符串和数字之间的转换是通过String(..)和 Number(..) 这两个内建函数来实现的，**注意他们前面没有 new 关键字**，并不是创建封装对象。

```js
var a = 42;
var b = String(a);

var c = "3.14";
var d = Number(c);

b;  // "42"
d;  // 3.14
```

除了 String() 和 Number() 以外，还有其他方法可以实现字符串和数字之间的显示转换：
```js
var a = 42;
var b = a.toString();

var c = "3.14";
var d = +c;     //使用一元操作符+来实现显式地将 c 转换为数字。

b;  // "42"
d;  // 3.14
```

上例中 +c 是 + 运算符的一元形式（即只有一个操作数）。

`+` 运算符显式地将 c 转换为数字，而非数字加法算法，也不是字符串拼接。

在 JS 开源社区，一元运算符+被普遍认为是显式强制类型转换。

不过这样有时候容易产生误会。例如：
```js
var c = "3.14";
var d = 5+ +c;

d;  // 8.14
```

尽量不要把一元运算符+（还有-）和其他运算符放在一起起使用。

### 1. 日期显示转换为数字

一元运算符`+` 的另一个常见用途是将日期（Date）对象强制转换为数字，返回结果是以微秒为单位的数字（从1970年1月1日开始）
```js
var d = new Date("Mon, 18 Aug 2014 08:53:06 CDT");
+d;     //1408369986000
```

我们常用下面的方法来获得当前的时间戳：
```js
var timestamp = +new Date();
```

将Date 对象转换为时间戳并非只有强制类型转换这种方法，或许使用更显式的方法会更好一些：
```js
var timestamp = (new Date()).getTime();
```
不过最好还是使用 ES5 中新家的静态方法 Date.now()：
```js
var timestamp = Date.now();
```

为老版本浏览器提供Date.now()的 polyfill 也很简单：
```js
if(!Date.now) {
    Date.now = function() {
        return +new Date();
    };
}
```

不建议对日期使用强制类型转换，应该使用 Date.now() 来获取当前的时间戳，使用 new Date(..).getTime()来获得指定的时间戳。


### 2. 奇特的`~`运算符（按位非 NOT）

一个常被人忽略的地方是`~`运算符（即字位操作“非”）相关的强制类型转换，它很让人费解，以至于了解它的人敬而远之。

字位运算符只适用于32位整数，运算符会强制操作数使用32位格式。而这个过程是通过**抽象操作** ToInt32来实现的。

ToInt32 首先会执行 ToNumber 强制类型转换，比如"25"会被转换为25，然后在执行 ToInt32。然后得到32位整数（二进制）结果是：00000000000000000000000000011001。

然后你对其进行数值进行取反码：
```js
var a = "25";   // 二进制（32位整数）：00000000000000000000000000011001
var b = ~ a;    // 二进制（32位整数）：11111111111111111111111111100110 （取反码）
console.log(b); // -26
```

严格来说，并非强制类型转换（因为返回值类型并没有发生变化），但字位运算符（如|和~）和某些特殊数字在一起会产生类似强制类型转换的效果，返回另外一个数字：

```js
0 | -0;         //0     
0 | NaN;        //0
0 | Infinity;   //0
0 | -Infinity;  //0
//0全部结果都为0
```
因为，这些特殊数字无法以32位格式呈现（-0，NaN，Infinity等）。

`~`位运算符实质是：**操作数的负值减1**

~x 大致等同于 -(X+1)。

```js
~42;    // -(42+1) ==> -43
```

在-(x+1)中唯一能够得到0（或者严格说是-0）的 x 值是 -1。也就是说 x 为-1时，~和其他一些数字值在一起会返回假值0，其他情况则返回真值。

```js
~-1;    //-(-1+1) ==> -0(假值)
```

-1 是一个“哨位值”，就是这个数字被赋予了特殊含义的值。

在 C 语言中-1代表函数执行失败，大于等于0的值来代表函数执行成功。

在 JS 中字符串的 indexOf() 方法也遵循这个惯例，这个方法在字符串中搜索指定的子字符串，如果找到就返回子字符串所在的位置（从0开始），否则返回-1。

indexOf()不仅能够得到子字符串的位置，还可以用来检查字符串是否包含指定的字符串，相当于一个条件判断。例如：

```js
var a = "Hello World";

if(a.indexOf("lo") >= 0) {  //true
    console.log("找到匹配");
}

if(a.indexOf("ol") < 0) {   // true
    console.log("没找到匹配");
}
```

`>=` 和 == -1 这样的写法不是很好，称为“抽象渗漏”，意思是在代码中暴露了底层的实现细节，这里是指用-1作为失败值时的返回值，这些细节应该被屏蔽掉。

我们终于明白了`~`的用处！

~和 indexOf() 一起可以将结果强制类型转换（实际上仅仅是转换）为真/假值：
```js
var a = "Hello World";

~a.indexOf("lo");   // -4 <-- 真值

if(~a.indexOf("lo")) {
    console.log("找到匹配");
}

~a.indexOf("ol");   // 0 <-- 假值

!~a.indexOf("ol");  // true

if(!~a.indexOf("ol")) {    //true
    console.log("没找到匹配");
}
```

如果 indexOf(..)返回-1，~将其转换为假值0，其他情况一律转为真值。


### 3. 字位截除

一些开发人员使用 ~~ 来截除数字值的小数部分，以为这和 Math.floor(..) 的效果一样，实际上并非如此。

`~~` 的第一个 ~ 执行 ToInt32 并反转字符，然后第二个~在执行一次，即将所有字位反转回原值，最后得到的仍然是 ToInt32 的结果。（和!!很相似）

对`~~`我们要多加注意。首先它只适用于32位数字，更重要的是它对负数的处理与 Math.floor() 不同。

```js
Math.floor(-49.6);  // -50
~~-49.6             // -49
```

小数取整的时：

`~~x` 能将数值截除为一个32位整数，`x | 0`同样也可实现小数取整，而且更加简洁。

```JS
49.5 | 0; //49
```

 在出于对运算符优先级的考虑情况下，我们可能更加倾向使用 `~~x`
```JS
~~1E20 / 10;    // 166199296

1E20 | 0 / 10;  // 1661992960
(1E20 | 0)/10;  // 166199296
```

在我们使用~和~~进行此类转换时，需要保证其他人能够看得懂。

## **4.3.2 显示解析数字字符串（parseInt）**

解析字符串中的数字和将字符强制转换为数字的返回结果都是数字。

但解析（parseInt）和转换（Number）两者之间还是右明显的差别。

例如：
```js
var a = "42";
var b = "42px";
Number(a);      //42
parseInt(a);    //42

Number(b);      //NaN
parseInt(b);    //42
```

解析（parseInt）允许字符串中含有非数字字符，解析按从左到右的顺序，如果遇到非数字字符就停止。

转换（Number）不允许出现非数字字符，否则会失败并返回 NaN。

parseInt 是针对的是字符串。如果向 parseInt 传入非字符串参数，非字符串参数会首先转

parseInt 第二个参数可以传入要转换的基数。

```js
var num = parseInt("20", 10); //10进制为基基数
```

从 ES5 开始 parseInt() 默认转换为十进制，除非另外指定。


### 解析非字符串

对于参数是非字符串，parseInt()先将参数强制转换为字符串，在进行解析，这样做没有任何问题。因为传递错误的参数而得到错误结果，并不能归咎于函数本身。

JavaScript 中所有值都有一个默认的字符串形式。


## **4.3.3 显式转换为布尔值** 

和前面的 String() 和 Number() 一样，Boolean() （不带 new）是显式的 ToBoolean 强制类型转换。
```js
var a = "0";
var b = [];
var c = {};

var d = "";
var e = 0;
var f = null;
var g;

Boolean(a); //true 
Boolean(b); //true 
Boolean(c); //true 

Boolean(d); //false
Boolean(e); //false
Boolean(f); //false
Boolean(g); //false
```

一般 Boolean() 这种强制类型转换方式很少用。

而最常用的显式强制类型转换为布尔值的方法是`!!`。（先取反，再变回原来布尔值）

```js
var a = "0";
var b = [];
var c = {};

var d = "";
var e = 0;
var f = null;
var g;

!!a; //true 
!!b; //true 
!!c; //true 

!!d; //false
!!e; //false
!!f; //false
!!g; //false
```

在 if() 括号内，如果没有使用 Boolean() 和 !!，就会自动**隐式**进行 ToBoolean 转换。

建议使用 Boolean() 和 !! 来进行显式转换以便于代码清晰易读。

显式 ToBoolean 的另外一个用处，是在 JSON 序列化过程中将值强制类型转换为 true 或 false：
```js
var a = {
    1,
    function() {/*..*/},
    2,
    function() {/*..*/}
}

JSON.stringify(a);  // "[1, null, 2, null]"

JSON.stringify(a, function(key, val)){
    if (typeof val == "function") {
        return !!val;
    }
    else {
        return val;
    }
});             // "[1, true, 2, true]"   
```

建议使用 Boolean(a) 和 !!a 来进行显式强制类型转换。

