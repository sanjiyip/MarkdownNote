# **语法**

JS 语法定义了词法规则（如运算符和关键词等）是如何构成可运行的程序代码的。

换句话说，只看词法不看语法会遗漏掉很多重要的细节。

本章介绍的是语法，虽然和开发人员直接打交道的是词法。

# 5.1 语句和表达式

开发人员常常将"语句"（statement）和“表达式”（expression）混为一谈。但是他们在 JS 中存在重要的差别。

区别：

JS，**语句相当于一个句子**，而**表达式就相当于句子中的短语**，运算符相当于句子中的标点符号和连接词。

JS 中表达式可以返回一个结果值。

```js
var a = 3 * 6;
var b = a;
b;
```
这里 3*6 是一个表达式(结果为18)。

第二行的 a 也只是一个表达式，第三行的 b 也是表达式。表达式 a 和 b 的结果都是18.

这三行代码都是包含表达式的**语句**。

var a = 3 * 6; ，var b = a;称为“声明语句”。因为它们声明了变量。

a = 3 * 6、b = a叫做赋值表达式。

第三行代码中只有一个表达式 b，同时它也是一个语句。虽然没什么意义，通常被称为“表达式语句”


## **5.1.1 语句的结果值**

**语句都有一个结果值**（undefined 也算）。 

获得结果值最直接的方法是在浏览器控制台中输入语句，默认情况下控制台会显示所执行的最后一条语句的结果值。

以赋值表达式 b = a 为例，其结果值是赋给 b 的值(18),但规范定义 var 的结果值是 undefined。

如果在控制台中输入 var a = 42;会得到结果值 undefined，而非42。

但是在我们代码中是没办法获得结果值的。说先弄清楚为什么要获得语句的结果值。

闲来看看其他语句的结果值。比如代码块{..}的结果值是它最后一个语句/表达式的结果。

例如：
```js
var b;

if (true) {
    b = 4 + 38;
}
```
在控制台会显示42，即最后一个语句/表达式 b = 4 + 38的结果值。

换句话说，代码块的结果就会如同一个**隐式的返回**，即返回最后一个语句的结果值。

但下面这样的代码无法运行：
```js
var a,b;

a = if(true) {
    b = 4 + 38;
};
```
因为语法不允许我们获得语句的结果值并将其赋值给例外一个变量。

获得语句的结果值的方法（ES5之前），使用 万恶的eval()来获取语句的结果值。（千万不要这么做）
```js
var a,b;
a = eval("if(true){b=4+38;}");
a;
```

ES7(我去，都7了)规范有一项"do 表达式"提案：

类似下面这样
```js
var a, b;
a = do {
    if(true) {
        b = 4 + 38;
    }
};
a;      //42
```

不过现在浏览器肯定没支持.

其目的是将语句当作表达式来处理了（为了语句中可以包含其他语句），从而不需要将语句封装为函数在调用 return 来返回值。

## **5.1.2 表达式的副作用**

大部分表达式没有副作用。例如：

```js
var a = 2;
var b = a + 3;
```

表达式 a + 3本身没有副作用。它的结果值为5，通过 b = a + 3赋值给变量 b。

最常见的副作用的表达式是函数调用。
```js
function foo() {
    a = a + 1;
}

var a = 1;

foo();      // 结果值为：undefined。副作用：a 的值被改变（因为 a 被重新赋值了）
a;          //2
```

递增运算符++ 和递减运算符 -- 都是医院运算符，它们既可以在前面，又可以用在右面
```js
var a = 42;
var b = a++;

a;  // 43
b;  // 42
```
++ 在前面时， 如 ++a，它的副作用（将 a 递增）产生在表达式返回结果值之前。而 a++ 的副作用则产生在返回结果之后。

要想 b 的值是43，那么应该使用逗号运算符将多个独立的表达式串联成一个语句：
```js
var a = 42, b;
b = (a++, a);
a;  // 43
b;  // 43
```
由于运算符优先级的关系，a 需要放在( )里面。

a++，a 中的第二个表达式a 在 a++之后执行，结果为43，并被赋值给 b。

再如 delete 运算符。

delete 用来删除对象中的属性和数组中的单元。它通常以单独一个语句的形式出现：
```js
var obj = {
    a: 42
};

obj.a;          // 42
delete obj.a;   //true
obj.a           //undefined
```
如果操作成功，delete 返回 true，否则返回 false。

其副作用是属性被从对象中删除。

另外一个有趣的例子是 = 赋值运算符。
```js
var a;
a = 42;
a;      //42
```
a = 42 中的=运算符看起来没有副作用，实际上它的结果值是42，它的副作用将42赋值给 a。

多个赋值语句串联时（链式赋值），赋值表达式（和语句）的结果值就能派上用场，比如：
```js
var a, b, c;
a = b = c = 42;
a;  //42
b;  //42
c;  //42
```

另一个需要注意的问题是：
```js
function vowels(str) {
    var matches;
    if(str) {
        matches = str.match(/[aeiou]/g);
        if(matches) {
            return matches;
        }
    }
}

vowels("Hello World");  //["e","o","o"]
```

上面的代码没问题。但我们可以利用赋值语句的副作用将两个 if 语句合二为一：
```js
function vowels(str) {
    var matches;
    if(str && (matches = str.match(/[aeiou]/g))) {
        return matches;
    }
}
vowels("Hello World");  //["e","o","o"]
```

### **5.1.3 上下文规则**

在 JavaScript 语法规则中，有时候同样的语法在不同的情况下会有不同的解释。

### 1. 大括号

下面两中情况下会用到大括号{..}。

**（1）对象常量**

用大括号定义对象常量。

var a = {
    foo: bar()
};

{ .. }被赋值给 a，因而它是一个对象常量。

### 2. 代码块

还有一个坑常被提到（涉及强制类型转换）
```JS
[] + {};    //"[object Object]"
{} + [];    // 0
```

{}出现在 + 运算符后面，这是它被当作一个值（空对象处理）。[]会被强制类型转换为" "，所以{}会被强制类型转换为"[object Object]"

而
```js
{} + [];

//实质就等于
{}      //类似 function(){} 这种，后面不用加分号
+[];    //  O
```

代码块结尾不需要分号(函数表达式除外)，所以不存在语法上的问题，最后+[]将显示强制类型转换。

### 3. 对象解构

从 ES6 开始， {..}也可以用于“解构赋值”，特别是对象的结构。

```js
function getData() {
    //..
    return {
        a : 42,
        b: "foo"
    };
}

var { a,b } = getData();

console.log(a, b);   //42 "foo"
```

{a, b} = .. 就是 ES6中的解构赋值，相当于下面的代码：
```js
var res = getData();
var a = res.a;
var b = res.b;
```

{a, b}实际上是{a:a, b:b}的简化版本。

{ .. }还可以用作函数命名参数的对象结构，方便隐式地用对象属性赋值：
```js
function foo({a, b, c}) {
    // 不再需要这样：
    // var a = obj.a, b = obj.b, c = objc.c
    console.log(a,b,c);
}

foo(
    {
        c: [1,2,3],
        a: 42,
        c: "foo"
    }
)   // 42 "foo" [1,2,3]
```

### 4. else if和可选代码块

很多人误以为 JS 中有 else if。事实上并没有，但 if 和 else 只包含单挑语句的时候可以省略代码块{ }。

比如：
```js
if (a) doSomething(a);
```

但建议加上{}:
```js
if (a) {doSomething(a);}
```

