# 4.4 隐式强制类型转换

隐式强制类型转换指的是那些隐蔽的强制类型转换，副作用也不是很明显。

显式强制类型转换旨在让代码更加清晰易读，而隐式强制类型转换看起来就像它的对立面，会让代码变得晦涩难懂。

对强制类型转换的诟病大多是**针对隐式强制类型转换**。

不要简单地把隐式强制类型转换当做”显式强制类型转换的对立面“，这样理解过于狭隘，忽略了他们之间一个细微却十分重要的区别。

隐式强制类型转换的作用是减少冗余，让代码更简洁。

## **4.4.1 隐式地简化**

隐式强制类型转换同样可以用来提高代码的可读性。然而强制类型转换也会带来一些负面影响，有时甚至弊大于利。我们应该学习怎么去其糟粕，取其精华。

## **4.4.2 字符串和数字之间的隐式强制类型转换**

现在介绍字符串和数字之间的隐式强制类型转换

`+`运算符既能够用于数字加法，也能用于字符串拼接。看例子：

```js
var a = "42";
var b = "0";

var c = 42;
var d = 0;

a + b;  // "420" 
c + d;  // 42
a + d;  // "420"
```
这里为什么会得到"420" 和 42 两个不同结果呢？

通常的理解是，因为**某一个**或者**两个操作数**都是字符串，所以`+`运算符执行的是字符串拼接操作。

但实际情况要复杂得多。例子：

```js
var a = [1, 2];
var b = [3, 4];

a + b; // "1,23,4"
```

a 和 b 都不是字符串，但是他们被隐式强制类型转换为字符串后进行拼接。

解释例子怎么做到隐式强制转换：

根据ES 规范，如果某个操作数是字符串或者能够通过以下步骤转为字符串的话，`+`运算符将进行**拼接操作**。如果其中一个操作数是对象（包括数组），则首先对其调用 ToPrimitive 抽象操作，该抽象操作在调用[[DefaultValue]]，以数字作为上下文。

你或许注意到这与 ToNumber 抽象操作处理对象的方式一样。因为数组的 valueOf() 操作无法得到简单基本类型值，于是它转而调用 toString()。因此上例中的两个数组变成"1,2"和"3,4"。`+`将它们拼接后返回"1,23,4"。

简单来说，如果 `+` 的其中一个操作数是字符串（或是通过以上步骤得到字符），则进行字符串拼接；否则执行数字加法。

有一个坑：`[] + {}` 与 `{} + []`得到结果不一样
```js
[] + {};    // "[object Object]"

{} + [];    // 0
```

### 数字 隐式类型转换 为字符串

我们可以将 数字 和 空字符串"" 相 `+` 来将数字转换为字符串：
```js
var a = 42;

var b = a + "";

b; //"42"
```

`+`作为数字加法操作时可以互换的，即 2 + 3 等同于 3 + 2。

`+`作为字符串拼接操作则不行，但对空字符""来说， `a + ""` 和 `"" + a` 结果是一样的.

a + "" 这样的隐式转换十分常见。

a + ""(隐式)和前面的 String(a) (显式)之间有一个细微的差别需要注意。
- `a + ""` 根据 ToPrimitive 抽象操作规则， `a + ""` 会对 a 调用 valueOf() 方法，然后通过 ToString 抽象操作将返回值转换为字符串。

- String(a) 则是直接调用 toString()

它们最后返回的都是字符串，但如果 a 是对象而非数字，结果可能会不一样！

例如：
```js
var a = {
    valueOf: function() {return 42;},
    toString: function() {return 4;}
}

a + "";     //"42"
String(a);  // "4"
```

因此，在定制 valueOf() 和 toString() 方法时需要特别小心，因为这会影响强制类型转换的结果。


### 字符串隐式强制类型转换为数组

```js
var a = "3.14";
var b = a - 0;

b;  //   3.14
```

`-`是数字减法运算符，因此 `a - 0` 会将 a 强制类型转换为数字。（同理 a*1 和 a/1 也只是用与数字，不过不太常见）。

对象的 - 操作 与 + 操作类型：
```js
var a = [3];
var b = [1];
a - b;  // 2
a + b;  // "31"
```

使用 `-` 运算符就能将字符串转换为数字。

为了执行减法运算， a 和 b 都需要被转为数字。首先要被转为字符串（通过 toString()），然后在转换为数字。

## 4.4.3 布尔值隐式强制转换为数字

某些复杂的布尔逻辑运算转换为数字加法的时候，隐式强制转换能派上大用场。

当然这种情况不多见，属于特殊情况特殊处理。

例子： 函数用途是表示参数中有且仅有一个参数为 true， 时，onlyOne(..)返回 true，使用了强制类型转换。
```js
function onlyOne(a,b,c) {
    return !!((a && !b && !c) || (!a && b && !c) || (!a && !b && c));
}

var a = true;
var b = false;

onlyOne(a, b, b);   // true
onlyOne(b, b, b);   // true
onlyOne(a, b, a);   // false
```

但是，当如果有多个参数时（4个、5个..甚至20个），上面代码就很难处理。

这是用就可以使用布尔值隐式强制类型转换为数字（0或1）。

和上面函数功能一样，都是检查参数中的是不是有且仅有1个 true 。
```js
function onlyOne() {
    var sum = 0;
    for (var i = 0; i < arguments.length; i++) {
        //跳过假值，和处理0一样，但避免了 NaN
        if (arguments[i]) {
            sum += arguments[i];
        }
    }
    return sum == 1;
}

var a = true;
var b = false;

onlyOne(b, a);   // true
onlyOne(b, ,b, a, b, b);   // true
onlyOne(a, b, a);   //false
```

通过 sum += arguments[i] 中的隐式强制类型转换，将真值（true）转换为 1 并进行累加。

如果有且仅有一个参数为 true，则结果为1；否则不等于1，sum == 1 条件不成立。

同样的功能也可以通过显式强制类型转换来实现：(不过参数可以传入非布尔类型的值)
```js
function onlyOne() {
    var sum = 0;
    for(var i=0; i < arguments.length; i++) {
        sum += Number(!!arguments[i]);
    }
    return sum === 1;
}
```

!!arguments[i]首先会将参数转换为 true 或 false。因此非布尔值参数在这里也是可以的。

比如： onlyOne("42", 0)。（不然的话，字符串会执行拼接操作，结果就不对了）。

转为布尔类型以后，再通过 Number() 显式强制类型转换为数字 0 或 1.

