# 4.5 宽松相对（==）和严格相对（===）

宽松相对（==）和严格相对（===）都是用来判断两个值是否”相等“，但是它们之间有一个重要的区别，特别是判断条件上。

常见的误区是：“== 检查值是否相等， === 检查值和类型是否相等”。听起来蛮有道理，但是还不够准确。

正确的解释这两个：**== 运行在相等比较中进行强制类型转换，而 === 不允许**

## **4.5.1 相等比较操作的性能**

== 会比 === 慢百万分值一秒。（嘿嘿，其实他们几乎性能上差不多的）。

== 和 === 都会检查操作数的类型。区别在于操作数类型不同时它们的处理方式不同。

## **4.5.2 抽象相等**

非常规的情况需要注意：
- **NaN 不等于 NaN**
- **+0 等于 -0**

对象（包括函数和数组）的宽松相等==。

两个对象指向同一个值时，即视为相等，不发生强制类型转换。

== 在比较两个不同类型的值时会发生隐式强制类型转换，会将其中之一或者两种都转换为相同的类型后再进行比较。

### 1. 字符串和数字之间的相等比较

```js
var a = 42;
var b = "42";

a == b;     //true
a === b;    // false
```

因为没有强制类型转换，所以 a===b 为 false。“42”与42不相等。

而 a == b 是宽松相等，即如果两个值的类型不同，则对其中之一或者两者都进行强制类型转换。

具体是怎么转换呢? 是a 从42转换为字符串，还是 b 从“42”转换为数字？
 
实际是这样的，是将 字符串 强制类型转换为 数字，再做比较。

## 2. 其他类型和布尔类型之间的相等比较

**== 最容易出错的一个地方是 true 和 false 与其他类型之间的比较**。

例如：
```js
var a = "42";
var b = true;

a == b;     //false
```
宽松相等比较时，`==`左右两边中的布尔值，会被强制类型转换为数字，然后进行比较。

因此：true 会强制类型转换为 1；false 会强制类型转换为 0;

所以`"42" == true`结果为 false，实际上变成了 "42" == 1 ,所以是 false。


注意，这里只说 == ， 因为 === true 和 === false 不允许强制类型转换。

```js
var a = "42";

// 不要这样用，条件判断不成立
if (a == true) {
    //..
}

// 不要这样用，条件判断不成立
if (a === true) {
    //..
}

// 这样的隐式用法没问题：
if (a) {
    //..
}

// 这样的显式用法更好：
if (!!a) {
    //..
}

// 这样的显式用法也很好：
if (Boolean(a)) {
    //..
}
```

### 3. null 和 undefined 之间的相等比较

null 和 undefined 之间 宽松相等 == 也涉及隐式强制类型转换。

```js
null == undefined;  //true
```

在宽松相等中 null 和 undefined 相等（它们也与自身相等），除此之外其他值都不存在这种情况。

```js
var a = null;
var b;  //undefined

a == b;     //true
a == null;  //true
b == null;  //true

a == false; //false
b == false; //false
a == 0;     //false
b == 0;     //false
a == "";    //false
b == "";    //false
```

**null 和 undefined 之间的强制类型转换是安全可靠的。**

例如：
```js
var a doSomething();

if (a == null) {
    //..
}
```

条件判断 a == null 仅在 doSomething()返回 null 或 undefined 其中之一时才为true，除此之外其他值都不成立，包括0，false，""这样的假值。

下面是上面代码显式的做法，不涉及强制类型转换。

```js
var a = doSomething();

if(a === undefined || a === null) {
    //..
}
```

**a == null 这样的隐式强制类型转换在保证安全性的同事还能提高代码可读性。**


## 4. 对象和非对象之间的相等比较

关于对象（对象、函数、数组）和基本类型（字符串、数字、布尔值）之间的宽松相等比较：

会将对象进行 ToPrimitive 抽象操作，先查找对象中的 valueOf() 方法并调用，（没有情况下）再查找对象中的 toString() 方法，并调用，将转为字符串，最后字符串强制类型转换为数字。

```js
var a = 42;
var b = [42];

a == b;     //true
```

数组[42]首先调用 ToPrimitive 抽象操作，返回"42"，变成"42" == 42，然后又变成 42 == 42，最后两者相等。

前面介绍过“拆封”，即“打开”封装对象（如 new String("abc"））,返回其中的基本类型值（"abc"）。

== 中的 ToPrimitive 强制类型转换也会实现对封装对象的”拆封“。

```js
var a = "abc";
var b = Object(a);      //和 new String(a) 一样效果

a === b;                // false
a == b;                 //true
```

a == b 结果为 true，因为 b 通过 ToPrimitive 进行强制类型转换（也叫”拆封“），并返回基础类型值”abc“，与 a 相等。

但是有一些值并不是这样，因为这些值没有对应的封装对象（null 和 undefined），所以也没法拆封。

```js
var a = null;
var b= Object(a);   // 和 Object 一样
a == b;             //false

var c = undefined;
var d = Object(b);  // 和 Object 一样
c == d;             //false

var e = NaN;
var f = Object(e);  // 和 Object 一样
e == f;             //false
```

因为没有对应的封装对象，所以 null 和 undefined 不能够被封装。

NaN 能够被封装为一个数字对象，但是拆封之后 NaN == NaN 返回 false。（因为 NaN 不等于 NaN）。

## **4.5.3 比较少见得情况**

看一下那些需要特别注意和避免的比较少见的情况。

### 1. 返回其他数字

```js
Number.prototype.valueOf = function() {
    return 3;
};

new Number(2) == 3;     // true
```

2 == 3 不会出现这种问题，因为2和3都是数字基本类型值，不会调用 Number.prototype.valueOf()方法。而 Number(2)涉及 ToPrimitive 强制类型转换，因此会调用 valueOf()。

### 2. 假值的相等

== 中的隐式强制类型转换最为人诟病的地方是假值的**相等比较**。

```js
"0" == null;            //false
"0" == undefined;       //false
"0" == false;           //true - - 晕
"0" == NaN;             //false
"0" == 0;               //true
"0" == "";              //false

false == null;          //fasle
false == undefined;     //fasle
false == NaN;           //fasle
false == 0;             //true - - 晕
false == "";            //true - - 晕
false = [];             //true - - 晕
false = {};             //false

"" == null;             //false
"" == undefined;        //false
"" == NaN;              //false
"" == 0;                //true - - 晕
"" == [];               //true - - 晕
"" == {};               //false

0 == null;              //false
0 == undefined;         //false
0 == NaN;               //false
0 == [];                //true - - 晕
0 == {};                //false 
```

### 3. 极端情况
更极端的例子：
```js
[] == ![];      //true
```
事情变得越来越疯狂了。看起来似乎是真值和假值的相等比较，结果不应该是 true，因为一个值不可能同时既是真值也是假值！

事实并非如此。!运算符会进行布尔值的显式强制类型转换。所以[] == ![]变成了[] == false。

前面我们讲过 false == []。所以也是没问题的。

还有一个坑常常被提到：
```js
0 == "\n";  //true
```
因为""、"/n"等空字符串被 ToNumber 强制类型转换为0。

上述七种情况基本涵盖了所有我们可能遇到的坑。（就是注释后面带了”晕“字的）

与前面24种情况列表（假值相等比较）相对应的是下面这个（真值相等比较）列表：
```js
42 == "43";     //false
"foo" == 42;    //false
"true" == true; //false

42 == "42";         //true  (强制类型转换为数字)
"foo" == ["foo"];   //true (用了 toValue() )
```

这些是非假值的常规情况，涉及的强制类型转换时安全的。

### 4. 完整性检查

完整性检查

相等比较中的强制类型转换的7个坑。

避免使用以下七种相等比较：
```js
"0" == false;   //true - - 晕
false == 0;     //true - - 晕
false == "";    //true - - 晕
false == [];    //true - - 晕
"" == 0;        //true - - 晕
"" == [];       //true - - 晕
0 == [];        //true - - 晕
```

```js
function doSomething(a) {
    if(a == "") {
        //..
    }
}
```
如果不小心碰到 doSomething(0) 和 doSomething([])这样的情况，结果会让你大吃一惊。

### 安全运用隐式强制类型转换

我们要对 == 两边的值进行认真推敲，以下两个原则可以让我们有效地避免出错。

- 如果两边的值中有 true 或者 false，千万不要使用 ==。
- 如果两边的值中有 []、 "" 、或者 0，尽量不要使用 ==。

这时最好用 === 来避免不经意的强制类型转换。这两个原则可以让我们避开几乎所有强制类型的坑。

这种情况下强制类型越显式越好，能省去很多麻烦。

所以 == 和 === 选择哪一个取决于是否允许在相等比较中发生强制类型转换。


# 4.6 抽象关系比较

a < b 涉及的隐式强制类型转换不太引人注意。

比较双方首先调用 ToPrimitive，如果 ToPrimitive 结果，其中一方出现非字符串，就根据 ToNumber 规则将双方强制类型转换为数字进行比较。
```js
var a = [42];
var b = ["43"];

a < b;  // true
b < a;  // false
```

如果比较双方都是字符串，则按字母顺序进行比较：
```js
var a = ["42"];
var b = ["043"];

a < b;  //fasle;
```

a 和 b 并没有被转换为数字，因为两个 ToPrimitive 返回的都是字符串，所以比较的是"42"和"043"两个字符串，它们分别为"4"和"0"开头。

因为"0"在字母顺序上小于"4"，所以最后结果为 false。

同理：
```js
var a = [4,2];
var b = [0,4,2];

a < b;  //false

```

a 转换为字符串"4,2", b 转换为字符串"0,4,3"，同样是按字母顺序进行比较。

再比如：

```js
var a = {b:42};
var b = {b:43};

a < b; //？？猜一下
```

结果还是 false,因为 a 是[object Object]，b 也是[object Object]，所以按字母顺序 a < b 并不成立。

下面的例子就有些奇怪了：
```js
var a = {b:42};
var b = {b:43};
a < b;  //false
a == b; //false
a > b;  //false

a <= b; //true
a >= b; //true
```

但如果 a < b 和 a == b 结果为 false，为什么 a <= b 和 a >= b 的结果会是 true?

因为根据规范 a <= b 被处理为 b < a ,然后再将比较的结果再取反。

因为 b < a 的结果是 false，所以 a <= b 的结果是 true。

实际上，JS 中 <= 是”不大于“的意思（即!(a > b)，在 js 处理为!(b < a)）。

要避免 a < b 中发生隐式强制类型转换，我们只能确保 a 和 b 为相同的类型，因为关系比较没有"严格关系比较"。

为了确保安全，应该对关系比较中的值进行显式强制类型转换：
```js
var a = [42];
var b = "043";

a < b;                  // false -- 字符串比较
Number(a) < Number(b);  // true -- 数字比较
```