# 4.5 宽松相对（==）和严格相对（===）

宽松相对（==）和严格相对（===）都是用来判断两个值是否”相等“，但是它们之间有一个重要的区别，特别是判断条件上。

常见的误区是：“== 检查值是否相等， === 检查值和类型是否相等”。听起来蛮有道理，但是还不够准确。

正确的解释这两个：**== 运行在相等比较中进行强制类型转换，而 === 不允许**

## **4.5.1 相等比较操作的性能**

== 会比 === 慢百万分值一秒。（嘿嘿，其实他们几乎性能上差不多的）。

== 和 === 都会检查操作数的类型。区别在于操作数类型不同时它们的处理方式不同。

## **4.5.2 抽象相等**

非常规的情况需要注意：
- **NaN 不等于 NaN**
- **+0 等于 -0**

对象（包括函数和数组）的宽松相等==。

两个对象指向同一个值时，即视为相等，不发生强制类型转换。

== 在比较两个不同类型的值时会发生隐式强制类型转换，会将其中之一或者两种都转换为相同的类型后再进行比较。

### 1. 字符串和数字之间的相等比较

```js
var a = 42;
var b = "42";

a == b;     //true
a === b;    // false
```

因为没有强制类型转换，所以 a===b 为 false。“42”与42不相等。

而 a == b 是宽松相等，即如果两个值的类型不同，则对其中之一或者两者都进行强制类型转换。

具体是怎么转换呢? 是a 从42转换为字符串，还是 b 从“42”转换为数字？
 
实际是这样的，是将 字符串 强制类型转换为 数字，再做比较。

## 2. 其他类型和布尔类型之间的相等比较

**== 最容易出错的一个地方是 true 和 false 与其他类型之间的比较**。

例如：
```js
var a = "42";
var b = true;

a == b;     //false
```
宽松相等比较时，`==`左右两边中的布尔值，会被强制类型转换为数字，然后进行比较。

因此：true 会强制类型转换为 1；false 会强制类型转换为 0;

所以`"42" == true`结果为 false，实际上变成了 "42" == 1 ,所以是 false。


注意，这里只说 == ， 因为 === true 和 === false 不允许强制类型转换。

```js
var a = "42";

// 不要这样用，条件判断不成立
if (a == true) {
    //..
}

// 不要这样用，条件判断不成立
if (a === true) {
    //..
}

// 这样的隐式用法没问题：
if (a) {
    //..
}

// 这样的显式用法更好：
if (!!a) {
    //..
}

// 这样的显式用法也很好：
if (Boolean(a)) {
    //..
}
```

### 3. null 和 undefined 之间的相等比较

null 和 undefined 之间 宽松相等 == 也涉及隐式强制类型转换。

```js
null == undefined;  //true
```

在宽松相等中 null 和 undefined 相等（它们也与自身相等），除此之外其他值都不存在这种情况。

```js
var a = null;
var b;  //undefined

a == b;     //true
a == null;  //true
b == null;  //true

a == false; //false
b == false; //false
a == 0;     //false
b == 0;     //false
a == "";    //false
b == "";    //false
```

**null 和 undefined 之间的强制类型转换是安全可靠的。**

例如：
```js
var a doSomething();

if (a == null) {
    //..
}
```

条件判断 a == null 仅在 doSomething()返回 null 或 undefined 其中之一时才为true，除此之外其他值都不成立，包括0，false，""这样的假值。

下面是上面代码显式的做法，不涉及强制类型转换。

```js
var a = doSomething();

if(a === undefined || a === null) {
    //..
}
```

**a == null 这样的隐式强制类型转换在保证安全性的同事还能提高代码可读性。**


## 4. 对象和非对象之间的相等比较

关于对象（对象、函数、数组）和基本类型（字符串、数字、布尔值）之间的宽松相等比较：

会将对象进行 ToPrimitive 抽象操作，先查找对象中的 valueOf() 方法并调用，（没有情况下）再查找对象中的 toString() 方法，并调用，将转为字符串，最后字符串强制类型转换为数字。

```js
var a = 42;
var b = [42];

a == b;     //true
```

数组[42]首先调用 ToPrimitive 抽象操作，返回"42"，变成"42" == 42，然后又变成 42 == 42，最后两者相等。

前面介绍过“拆封”，即“打开”封装对象（如 new String("abc"））,返回其中的基本类型值（"abc"）。

== 中的 ToPrimitive 强制类型转换也会实现对封装对象的”拆封“。

```js
var a = "abc";
var b = Object(a);      //和 new String(a) 一样效果

a === b;                // false
a == b;                 //true
```

a == b 结果为 true，因为 b 通过 ToPrimitive 进行强制类型转换（也叫”拆封“），并返回基础类型值”abc“，与 a 相等。

但是有一些值并不是这样，因为这些值没有对应的封装对象（null 和 undefined），所以也没法拆封。

```js
var a = null;
var b= Object(a);   // 和 Object 一样
a == b;             //false

var c = undefined;
var d = Object(b);  // 和 Object 一样
c == d;             //false

var e = NaN;
var f = Object(e);  // 和 Object 一样
e == f;             //false
```

因为没有对应的封装对象，所以 null 和 undefined 不能够被封装。

NaN 能够被封装为一个数字对象，但是拆封之后 NaN == NaN 返回 false。（因为 NaN 不等于 NaN）。
