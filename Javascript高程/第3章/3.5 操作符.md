# 3.5 操作符（运算符）
------
> EMCA-262描述了一组用于操作数据值的**操作符**，包括算术操作符（如加号和减号）、位操作符、关系操作符和相等操作符。EMCAScript操作符与众不同的地方在于，它能够适用于很多值，例如字符串、数字值、布尔值，甚至对象。

## 3.5.1 一元操作符
只能操作一个值的操作符叫做**一元操作符**。

### 1. 递增和递减操作符

递增和递减操作符各有两个版本：**前置型**和**后置型**，前置型位于操作的变量之前，后置型应该位于操作变量之后。
- #### 前置递增和递减操作符
    - 执行**前置递增和递减操作**时，*变量的值都是在语句被求值以后改变的*。（在计算机领域被称作**副效应**）。
    - 口诀：**先求值**，后运算。(求值是求变量自身的值，运算是运算和该变量有关的语句。)
    ```js
    var num1 = 2;
    var num2 = 20;
    var num3 = --num1 + num2;//等于21
    var num4 = num1 + num2;//等于21
    ```
- #### 后置递增和递减操作符
    - **后置递增和递减操作**是在包含它们的语句被求值之后才执行。（它们：*是指具有后置递增和递减操作符的变量*）
    - 口诀：**后求值**，先运算。(求值是求变量自身的值，运算是运算和该变量有关的语句。)
    ```js
    var num1 = 2;
    var num2 = 20;
    var num3 = num1-- + num2;//等于22
    var num4 = num1 + num2;//等于21
    ```
- #### 这4个操作符对任何类型的值都适用，还可以用于字符串、布尔值、浮点数值和对象。
    应用于不同类型值的时候，递增和递减操作符遵循下列规则。
    
    - 在应用于一个**包含有效数字字符的字符串**时，先将其转换为数字值，再执行加减1的操作。**字符串变量变成数字变量**。
    - 在应用于一个**不包含有效数字字符的字符串**时，将变量的值设置为`NaN`。**字符串变量变成数字变量**。
    - 在应用于**布尔值**`true`时，先将其转换为0再执行加减1的操作。**布尔值变量变成数值变量**。
    - 在应用于**布尔值**`false` 时，先将其转换为1再执行加减1的操作。**布尔值变量变成数值变量**。
    - 应用于**浮点数值**时，执行加减1的操作。
    - 应用于**对象**时，先调用对象的`valueOf()`方法，以取得一个可供操作的值。然后对该值应用前述规则。如果结果是`NaN`,则在调用`toString()`方法后再应用前述规则。**对象变量变成数值变量**。
    ```js
    var s1 = "2";
    var s2 = "z";
    var b = false;
    var f = 1.1;
    var o = {
        valueOf: function() {
            return -1;
        }
    };

    s1++;//值变成数值3
    s2++;//值变成NaN
    b++;//值变成数值1
    f--;//值变成数值0.10000000000000009(浮动舍入误差导致)
    o--;//值变成数值-2
    ```

### 2. 一元加和减操作符(+)
- #### 一元加
    - 一元加操作符以一个加号（+）表示，放在数值前面，对数值不会产生任何影响。
    ```js
    var num = 25;
    num = +num;  //仍然是25
    ```
    - 在对**非数值类型**应用*一元加操作符*时，该操作符会像`Number()`转型函数一样对这个值执行转换。简单点说，就是添加了一元加操作符的值，会试图转为数值类型。如：布尔值false和true将被转换成0和1。
    ```js
    var s1 = "2";
    var s2 = "z";
    var b = false;
    var f = 1.1;
    var o = {
        valueOf: function() {
            return -1;
        }
    };

    +s1;//值变成数值2
    +s2;//值变成NaN
    +b;//值变成数值0
    +f;//值变成数值1.1
    +o;//值变成数值-1
    ```
- #### 一元减(-)
    - 一元减操作符主要用于表示负数。
    ```js
    var num = 25;
    num = -num; //变成了-25
    ```
    - 同理，对**非数值类型**应用一元减操作符时，和一元加操作符相同的规则，最后再将得到的数值转换为负数。

------

## 3.5.2 位操作符 （了解）
参考：[ECMAScript 位运算符](http://www.w3school.com.cn/js/pro_js_operators_bitwise.asp)

- 按位非(NOT)
- 按位与(AND)
- 按位或(OR)
- 按位异或(XOR)
- 左移(\<<)
- 有符号的右移(\>>)
- 无符号的右移(\>>>)

ECMAScript 整数有两种类型，即有符号整数（允许用正数和负数）和无符号整数（只允许用正数）。*在 ECMAScript 中，所有整数字面量默认都是有符号整数*。只有 ECMAScript 的位运算符才能创建无符号整数。

- **有符号整数**使用 31 位表示整数的数值，用*第32位*表示整数的符号，0 表示正数，1 表示负数。数值范围从 -2147483648 到 2147483647。**无符号整数**的数值范围为 0 到 4294967295。
- **有符号整数**可以以两种不同的方式存储二进制形式的有符号整数，一种用于存储正数，一种用于存储负数。正数是以真二进制形式存储的。


### 1. 位运算 `NOT`—— 求反码的过程
位运算 `NOT` 由波浪线（`~`）表示，执行运算符 NOT的结果就是返回**数值的反码**。它是 ECMAScript 中为数不多的与二进制算术有关的运算符之一。

```js
var num1 = 25;       //25 等于 00000000000000000000000000011001
var num2 = ~num1;   //转换为 11111111111111111111111111100110
console.log(num2); //输出 -26
```
**位运算 NOT 实质**上是**对数字求负，然后减 1**，因此 25 变 -26。用下面的方法也可以得到同样的方法：
```js
var num1 = 25;     
var num2 = -num1 - 1;   
console.log(num2); //输出 -26
```

### 2. 位运算 `AND`
位运算 AND 由和号（`&`）表示，直接对**数字的二进制形式进行运算**。它把每个数值的每一位对齐，然后用下面的规则对同一位置上的两个数位进行 AND 运算：**任何一位是0**，结果都是**0**。
```js
var result = 25 & 3;
console.log(result); // 1
```
```
 25 = 0000 0000 0000 0000 0000 0000 0001 1001
  3 = 0000 0000 0000 0000 0000 0000 0000 0011
---------------------------------------------
AND = 0000 0000 0000 0000 0000 0000 0000 0001
```
上面这个例子，先将两个数转为二进制形式，然后对比对应的每一位数。如果对应的数字都是1，才返回1。任何一位是0，；

### 3. 位运算 `OR`
位运算 OR 由符号（`|`）表示，也是直接对**数字的二进制形式进行运算**。在计算每位时，OR 运算符采用下列规则：有一个位是1的情况下就返回1，而只有在**对应两个位都是0**的情况下才返回**0**。
```js
var result = 25 | 3;
console.log(result); // 27
```
```
25 = 0000 0000 0000 0000 0000 0000 0001 1001
3  = 0000 0000 0000 0000 0000 0000 0000 0011
--------------------------------------------
OR = 0000 0000 0000 0000 0000 0000 0001 1011
```
可以看出，在两个数字中，共有 4 个数位存放的是 1，这些数位被传递给结果。二进制代码 11011 等于 27。

### 4. 位运算 `XOR`(异或)
位运算 XOR 由符号（`^`）表示，当然，也是直接对二进制形式进行运算。XOR 不同于 OR，如果**对应的两位都是1或都是0**，则返回**0**；

对 25 和 3 进行 XOR 运算，代码如下：
```js
var iResult = 25 ^ 3;
alert(iResult);	//输出 "26"
25 和 3 进行 XOR 运算的结果是 26：
```
```
 25 = 0000 0000 0000 0000 0000 0000 0001 1001
  3 = 0000 0000 0000 0000 0000 0000 0000 0011
---------------------------------------------
XOR = 0000 0000 0000 0000 0000 0000 0001 1010
```

### 5. 左移运算（`<<`）
左移运算由两个小于号表示（`<<`）。它把数字中的**所有数位向左移动**指定的数量。例如，把数字 2（等于二进制中的 10）左移 5 位，结果为 64（等于二进制中的 1000000）：*移多少位就叫多少个0*
```js
var oldValue = 2;               //等于二进制 10
var newValue = oldValue << 5;  //等于二进制 1000000 , 十进制 64
```
***注意***：左移运算保留数字的符号位。例如，如果把 -2 左移 5 位，得到的是 -64，而不是 64。

### 6. 右移运算(`>>`)
有符号右移运算符由两个大于号表示（>>）。它把 32 位数字中的所有数位整体右移，同时保留该数的符号（正号或负号）。**有符号右移运算符**恰好与左移运算相反。例如，把 64 右移 5 位，将变为 2：
```js
var iOld = 64;		//等于二进制 1000000
var iNew = iOld >> 5;	//等于二进制 10 十进制 2
```

### 7. 无符号的右移运算(`>>>`)
无符号右移运算符由三个大于号（>>>）表示，它将无符号 32 位数的所有数位整体右移。**对于正数，无符号右移运算的结果与有符号右移运算一样**。
```js
var iOld = 64;		//等于二进制 1000000
var iNew = iOld >>> 5;	//等于二进制 10 十进制 2
```
**对负数，无符号右移运算的结果与有符号右运算就不一样了**

首先，无符号右移是以0来填充空位（负数就会变正数）。其次，无符号右移会操作符会把负数的二进制码当做整数的二进制码。而且，由于**负数以其绝对值的 *二进制补码* 形式表示**，因此无符号右移的结果会非常之大。
```js
var oldValue = -64;		//等于二进制 111111111111111111111111100000
//十进制64的二进制值为10000，-64的要通过二进制补码得到
var newValue = iOld >>> 5;	//等于十进制 134217726
```