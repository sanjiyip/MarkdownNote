# 4.3垃圾收集
---
JavaScript具有自动垃圾收集机制，执行环境会负责管理代码执行过程中的内存。
垃圾收集机制的原理：找出那些不在继续使用的变量，然后释放其占用的内存。为此，垃圾收集器会按照固定的事件间隔(或代码中预定的收集事件)，周期性执行这一操作。

局部变量的正常生命周期。
局部变量只有在函数执行的过程中存在。而在这个过程中，会为局部变量在栈（或堆）内存上分配相应的空间，以便存储它们的值。然后在函数中使用这些变量，直至函数执行结束。此时，局部变量就没有存在的必要了，因此可以释放它们的内存以供将来使用。

垃圾收集器必须跟踪那个变量有用哪个变量没用，**对于不再有用的变量打上标记**，以备将来收回其占用的内存。

## 4.3.1 标记清除
JavaScript中最常用的垃圾收集方式是标记清除。
- 当变量进入环境(例如，在函数中声明一个变量)时，就将这个变量标记为“进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就会可能用到它们。
- 而当变量离开环境时，将其标记为“离开环境”。

如何标记变量不重要，关键在于采取什么策略。标记清除策略下，垃圾收集器具体的运行过程：
- 垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记。
- 然后，它会去掉环境中的变量已经被环境中的变量引用的变量的标记。而剩下被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。
- 最后垃圾收集器完成**内存清除**工作，销毁那些带标记的值并回收它们所占用的内存空间。

---

## 4.3.2 引用计数(另一种不常见的垃圾收集策略)
引用计数的含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型值赋给该变量时，则这个值得引用次数就是次数就是1.如果同一个值被赋值给另外一个变量，则该值的引用次数加1。相反，如果包含对这个值引用的变量又去取得另外一个值，则这个值得引用次数减1。当这个值的引用次数变成0时，表示没办法再访问这个值，就会回收它所占用的内存空间。

不过，这种策略会产生引种问题：循环引用。
- 循环引用是指对象A中包含一个指向对象B的指针，而对象B中也包含一个指向对象A的引用。

----

## 4.3.3 性能问题
垃圾收集器是周期性运行的，确定垃圾收集的时间间隔是非常重要的一个问题。

## 4.3.4 管理内存
由于防止运行JavaScript的页面耗尽全部系统资源而导致系统崩溃，所以分配给web浏览器的可用内存数量通常比分配给系统应用程序要少。内存限制问题不仅会影响给变量分配内存，同时还会影响调用栈已经在一个线程中能够同时执行的语句数量。

为了应对这个问题，优化内存占用的最佳方式，就是执行中的代码只保留必要的数据。一旦数据不再有用，最好通过将其设**置为null来释放其引用**，这个做法叫做解除引用（dereferencing）。这一做法适用于大多数全局变量和全局对象的属性。局部变量会在他们离开执行环境时自动被解除引用。例子：
```js
function createPerson(name) {
    var localPerson = new Object()；
    localPerson.name = name；
    return localPerson；
}
var globalPerson = createPerson("Nicholas");
//手动解除globalPerson的引用
globalPerson = null;
```
不过，解除一个值的引用并不意味这自动回收该值所占用的内存。解除引用的真正作用是让值脱离执行环境，以便垃圾收集器下次运行时将其回收。
