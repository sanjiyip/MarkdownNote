# 函数

## 带参数默认值的函数

### 在 ES5 中模拟参数默认值

在 ES5 或更早的版本中，你可能会使用下述模式来创建带有参数默认值的函数：

```js
function makeRequest(url, timeout, callback) {
  timeout = timeout || 2000;
  callback = callback || function () {};
  // 函数的剩余部分
}
```

不过此方法有个瑕疵，此处的 timeout 的有效值实际上有可能是 0 ， 但因为 0 是假值，就会导致 timeout 的值在这种情况下会被替换为 2000 。

在这种情况下，更安全的替代方法是使用typeof来检测参数的类型，正如下例：

```js
function makeRequest(url, timeout, callback) {
  timeout = (typeof timeout !== "undefined") ? timeout : 2000;
  callback = (typeof callback !== "undefined") ? callback : functio() {};
  // 函数的剩余部分
}
```

虽然这种方法更安全，但依然为实现一个基本需求而书写了过多的代码。

### ES6 中的参数默认值

ES6 能更容易地为参数提供默认值，它使用了初始化形式，以便在参数未被正式传递进来时 使用。例如：

```js
function makeRequest(url, timeout = 2000, callback = function(){}) {
  // 函数的剩余部分
}
```

函数调用时，对持有默认值的参数不传递值，或明确将该参数值的指定为undefined时，参数的默认值才会被使用。

### 参数默认值如何影响 arguments 对象

需要记住的是， arguments 对象会在使用参数默认值时有不同的表现。

在 ES5 的非严格模 式下， arguments 对象会反映出具名参数的变化。

```js
function mixArgs(first, second) {
  "use strict";
  console.log(first === arguments[0]);  // true
  console.log(second === arguments[1]); // true

  first = "c";
  second = "d"

  console.log(first === arguments[0]); // true
  console.log(second === arguments[1]); // true
}
```

然而在 ES5 的严格模式下，关于 **arguments 对象的这种混乱情况被消除了，它不再反映出具名参数的变化**。 如下：

```js
function mixArgs(first, second) {
  "use strict";
  console.log(first === arguments[0]);  // true
  console.log(second === arguments[1]); // true

  first = "c";
  second = "d"

  console.log(first === arguments[0]); // false
  console.log(second === arguments[1]); // false
}
```

使用 ES6 参数默认值的函数中， arguments 对象的表现总是会与 ES5 的严格模式一 致，无论此时函数是否明确运行在严格模式下。参数默认值的存在触发了 arguments 对象与具名参数的分离。

```js
function mixArgs(first, second = "b") {

  console.log(arguments.length);  // 1

  console.log(first === arguments[0]);  // true
  console.log(second === arguments[1]); // false (因为second为"b"，而arguments[1]为undefined)

  first = "c";
  second = "d"
  console.log(first)
  console.log(first === arguments[0]); // false
  console.log(second === arguments[1]); // false
}

mixArgs("a");
```

在本例中 arguments.length 的值为1，因为只给 mixArgs() 传递了一个参数。也意味着arguments[1]的值为undefined，符合将单个参数传递给函数时的预期。

无论是否严格模式下，你可以始终已经arguments对象来反映初始传入的参数是什么。（arguments[num]）

### 参数默认值表达式

参数默认值最有意思的特性或许就是默认值并不要求一定是基本类型的值。

例如，你可以**执行一个函数**来产生参数的默认值，就像这样：

```js
function getValue() {
  return 5;
}
function add(first, second = getValue()) {
  return first + second;
}

console.log(add(1,1));  // 2
console.log(add(1));    // 6
```

将函数调用作为参数的默认值时需要小心，如果你遗漏了括号，例如在上面例子中使用 second = getValue ，你就传递了对于该函数的一个引用，而没有传递调用该函数的结果。

#### 前面的参数作为后面参数的默认值

例子：

```js
function add(first, second = first) {
  return first + second;
}

console.log(add(1,1));  // 2
console.log(add(1));    // 2
```

进一步说，你可以将 first 作为参数传递给一个函数来产生 second 参数的值：

```js
function getValue(value) {
  return value + 5;
}
function add(first, second = getValue(first)) {
  return first + second;
}

console.log(add(1,1));  // 2
console.log(add(1));    // 7
```

引用其他参数来为参数进行默认赋值时，仅允许引用前方的参数，因此前面的参数不能访问 后面的参数。

```js
function add(first = second, second) {
  return first + second;
}
console.log(add(1,1));  // 2
console.log(add(undefined, 1)); // 报错
```

造成的原因：参数默认值的暂时性死区

### 参数默认值的暂时性死区

与 let 和 const 的 TDZ 类似，参数默认值同样有着无法访问特定参数的暂时性死区。

与 let 声明相似，函数每个参数都会创建一个新的标识符绑定，它在初始化之前不允许被访问，否则会抛出错误。

参数初始化是在函数被调用时进行的。

**函数参数拥有各自的作用域和暂时性死区，与函数体的作用域相分离**。

这意味着参数的默认值不允许访问在函数体内部声明的任意变量。例子：

```js
function add(first, second = third) {
  let third = 3;
  return first + second + third;
}

console.log(add(1)); // 报错
```

## 使用不具名参数

### ES5 中的不具名参数

JS 的函数并不强求参数的数量要等于已定义具名参数的数量，你所传递的参数总是允许少于或多于正式指定的参数。

不具名参数：就是声明函数的时候没有写明的参数，但是调用函数传参的时候，又多传了参数，而这些声明函数时没有名字的参数是使用通过arguments对象进行调用。

```js
// pick() 函数有不具名参数
function pick(object) {
  let result = Object.create(null);

  // 从第二个参数开始处理，因为第一个是对象，后面则是对象的属性
  for (let i=1, len=arguments.length; i < len; i++) {
    result[arguments[i]] = object[arguments[i]];
  }
  return result;
}

let book = {
  title: "Understanding ES6",
  author: "Nicholas C. Zakas",
  year: 2015
}

let bookData = pick(book, "author", "year");

console.log(bookData.author); // "Nicholas C. Zakas"
console.log(bookData.year);   // 2015
```

### 剩余参数