# Set 与 Map （新的集合类型）

Set 类型是一个不包含重复值的有序列表。

Map 则是键与相对应的值的集合。

因此， Map 中的每个项都存储了两块数据，通过指定所需读取的键即可检索对应的值。 Map 常被用作缓存，存储数据以便此后快速检索。

## Set

创建 Set 并添加项目

使用 new Set() 来创建 Set，调用 add() 方法能向 Set 中添加项，检查 size 属性能查看其中包含多少项。

可以使用数组来初始化一个 Set ，并且 Set 构造器会确保不重复地使用这些值

### weak set

Weak Set 与正规 Set 之间最大的区别是对象的弱引用。

## ES6 的 Map

ES6 的 Map 类型是键值对的有序列表，而键和值都可以是任意类型。

## 关于解决内存泄漏的问题：

[JavaScript 内存泄漏教程](http://www.ruanyifeng.com/blog/2017/04/memory-leak.html)

记得看评论：

```js
let arr = [1, 2, 3, 4];
console.log("hello world");
arr = null;
```

这段代码作为范例来说是不妥的，因为没有考虑函数的问题。

虽然理论上来说，不使用的变量需要清除，但在 js 的实际编程中大部分情况下不应当这样手动清除，而且一般的编程规范也不会建议这么做。

变量如果定义在函数内部，当函数运行完成后，这些内部变量就会完成它的生命周期，能够被垃圾回收，没有必要做手动清除。

变量如果定义在全局，那就不是需不需要清除的问题，而是首先要考虑有没有必要把变量定义在全局的问题。将临时变量定义在全局，这是需要纠正的一个不良习惯，纠正这种习惯的重要性要远远高于清除全局临时变量值的行为。

函数执行完毕后内部变量的值依然会被保留，这种情况当然也可能出现，也就是遇到了常说的“闭包”。对于闭包来说，并不是外层函数的所有变量都会被保留，引擎会进行优化，仅保留会在内层函数中引用的外层变量。那么问题就来了：既然形成闭包后，内层函数会用到的外层变量才会被保留，这样会被留下来继续保留引用的变量，就代表这些变量是有用的，为什么要清除它们呢？此外，对于在闭包内层函数中它自身定义的局部作用域的变量，这些局部变量一般情况下仍然是会完成其生命周期、被自动回收的。

总结来说：应尽量避免定义全局的临时变量，而函数内部仅涉及到本级作用域的变量（不会被闭包保留引用的）无需手动清除。对于全局公共变量、以及闭包内引用变量来说，仅在变量确实使用完毕、值不再需要保留时，才需要手动清除变量的值。

对于浏览器来说，还需要考虑 DOM 元素的情况。如果某个变量（以及对象类型变量上的属性、元素）保留了对于 DOM 元素的引用，包括引用本页的元素或同源的 iframe 内的元素等情况，当该元素在页面上被删除时，对于它的引用很可能还被保留在变量内，这样就会造成内存泄露。这视乎目标 DOM 元素是否易变的问题，不可一概而论，是复杂单页应用尤其要考虑的问题。对于易变的 DOM 元素，除了做一个公共的释放引用的方法外，也可以考虑不在变量上缓存对于 DOM 元素的引用、宁可牺牲一点点性能、每次都进行查询（现查现用）。这方面的平衡点需要根据实际情况来选择。

原文对于 WeakSet 和 WeakMap 的描述有点问题：“它们对于值的引用都是不计入垃圾回收机制的”。这里的“值”是不是应该改为“键”？

Map 体现为键/值对（ Set 则是键值一体）， WeakMap 只有对于键的引用是弱引用，对于其中值的引用则是强引用。

当然，这段原文中所提到的“值”与“键/值对”中的“值”很可能不是指同一个概念，所以也不能说它是完全错误的，但毕竟表述不严谨，可能引起误解。或许原文换一种表述方式会更妥当些，例如“在 WeakSet 的值和 WeakMap 的键上对于对象的引用都是弱引用，都是不计入垃圾回收机制的”。
